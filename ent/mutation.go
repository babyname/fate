// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/babyname/fate/ent/character"
	"github.com/babyname/fate/ent/idiom"
	"github.com/babyname/fate/ent/ncharacter"
	"github.com/babyname/fate/ent/predicate"
	"github.com/babyname/fate/ent/version"
	"github.com/babyname/fate/ent/wugelucky"
	"github.com/babyname/fate/ent/wuxing"
	"github.com/google/uuid"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeCharacter  = "Character"
	TypeIdiom      = "Idiom"
	TypeNCharacter = "NCharacter"
	TypeVersion    = "Version"
	TypeWuGeLucky  = "WuGeLucky"
	TypeWuXing     = "WuXing"
)

// CharacterMutation represents an operation that mutates the Character nodes in the graph.
type CharacterMutation struct {
	config
	op                            Op
	typ                           string
	id                            *string
	pin_yin                       *[]string
	appendpin_yin                 []string
	ch                            *string
	radical                       *string
	radical_stroke                *int
	addradical_stroke             *int
	stroke                        *int
	addstroke                     *int
	is_kang_xi                    *bool
	kang_xi                       *string
	kang_xi_stroke                *int
	addkang_xi_stroke             *int
	simple_radical                *string
	simple_radical_stroke         *int
	addsimple_radical_stroke      *int
	simple_total_stroke           *int
	addsimple_total_stroke        *int
	traditional_radical           *string
	traditional_radical_stroke    *int
	addtraditional_radical_stroke *int
	traditional_total_stroke      *int
	addtraditional_total_stroke   *int
	name_science                  *bool
	wu_xing                       *string
	lucky                         *string
	regular                       *bool
	traditional_character         *[]string
	appendtraditional_character   []string
	variant_character             *[]string
	appendvariant_character       []string
	comment                       *[]string
	appendcomment                 []string
	science_stroke                *int
	addscience_stroke             *int
	clearedFields                 map[string]struct{}
	done                          bool
	oldValue                      func(context.Context) (*Character, error)
	predicates                    []predicate.Character
}

var _ ent.Mutation = (*CharacterMutation)(nil)

// characterOption allows management of the mutation configuration using functional options.
type characterOption func(*CharacterMutation)

// newCharacterMutation creates new mutation for the Character entity.
func newCharacterMutation(c config, op Op, opts ...characterOption) *CharacterMutation {
	m := &CharacterMutation{
		config:        c,
		op:            op,
		typ:           TypeCharacter,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCharacterID sets the ID field of the mutation.
func withCharacterID(id string) characterOption {
	return func(m *CharacterMutation) {
		var (
			err   error
			once  sync.Once
			value *Character
		)
		m.oldValue = func(ctx context.Context) (*Character, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Character.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCharacter sets the old Character of the mutation.
func withCharacter(node *Character) characterOption {
	return func(m *CharacterMutation) {
		m.oldValue = func(context.Context) (*Character, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CharacterMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CharacterMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Character entities.
func (m *CharacterMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CharacterMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CharacterMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Character.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPinYin sets the "pin_yin" field.
func (m *CharacterMutation) SetPinYin(s []string) {
	m.pin_yin = &s
	m.appendpin_yin = nil
}

// PinYin returns the value of the "pin_yin" field in the mutation.
func (m *CharacterMutation) PinYin() (r []string, exists bool) {
	v := m.pin_yin
	if v == nil {
		return
	}
	return *v, true
}

// OldPinYin returns the old "pin_yin" field's value of the Character entity.
// If the Character object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharacterMutation) OldPinYin(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPinYin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPinYin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPinYin: %w", err)
	}
	return oldValue.PinYin, nil
}

// AppendPinYin adds s to the "pin_yin" field.
func (m *CharacterMutation) AppendPinYin(s []string) {
	m.appendpin_yin = append(m.appendpin_yin, s...)
}

// AppendedPinYin returns the list of values that were appended to the "pin_yin" field in this mutation.
func (m *CharacterMutation) AppendedPinYin() ([]string, bool) {
	if len(m.appendpin_yin) == 0 {
		return nil, false
	}
	return m.appendpin_yin, true
}

// ResetPinYin resets all changes to the "pin_yin" field.
func (m *CharacterMutation) ResetPinYin() {
	m.pin_yin = nil
	m.appendpin_yin = nil
}

// SetCh sets the "ch" field.
func (m *CharacterMutation) SetCh(s string) {
	m.ch = &s
}

// Ch returns the value of the "ch" field in the mutation.
func (m *CharacterMutation) Ch() (r string, exists bool) {
	v := m.ch
	if v == nil {
		return
	}
	return *v, true
}

// OldCh returns the old "ch" field's value of the Character entity.
// If the Character object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharacterMutation) OldCh(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCh is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCh requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCh: %w", err)
	}
	return oldValue.Ch, nil
}

// ResetCh resets all changes to the "ch" field.
func (m *CharacterMutation) ResetCh() {
	m.ch = nil
}

// SetRadical sets the "radical" field.
func (m *CharacterMutation) SetRadical(s string) {
	m.radical = &s
}

// Radical returns the value of the "radical" field in the mutation.
func (m *CharacterMutation) Radical() (r string, exists bool) {
	v := m.radical
	if v == nil {
		return
	}
	return *v, true
}

// OldRadical returns the old "radical" field's value of the Character entity.
// If the Character object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharacterMutation) OldRadical(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRadical is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRadical requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRadical: %w", err)
	}
	return oldValue.Radical, nil
}

// ResetRadical resets all changes to the "radical" field.
func (m *CharacterMutation) ResetRadical() {
	m.radical = nil
}

// SetRadicalStroke sets the "radical_stroke" field.
func (m *CharacterMutation) SetRadicalStroke(i int) {
	m.radical_stroke = &i
	m.addradical_stroke = nil
}

// RadicalStroke returns the value of the "radical_stroke" field in the mutation.
func (m *CharacterMutation) RadicalStroke() (r int, exists bool) {
	v := m.radical_stroke
	if v == nil {
		return
	}
	return *v, true
}

// OldRadicalStroke returns the old "radical_stroke" field's value of the Character entity.
// If the Character object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharacterMutation) OldRadicalStroke(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRadicalStroke is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRadicalStroke requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRadicalStroke: %w", err)
	}
	return oldValue.RadicalStroke, nil
}

// AddRadicalStroke adds i to the "radical_stroke" field.
func (m *CharacterMutation) AddRadicalStroke(i int) {
	if m.addradical_stroke != nil {
		*m.addradical_stroke += i
	} else {
		m.addradical_stroke = &i
	}
}

// AddedRadicalStroke returns the value that was added to the "radical_stroke" field in this mutation.
func (m *CharacterMutation) AddedRadicalStroke() (r int, exists bool) {
	v := m.addradical_stroke
	if v == nil {
		return
	}
	return *v, true
}

// ResetRadicalStroke resets all changes to the "radical_stroke" field.
func (m *CharacterMutation) ResetRadicalStroke() {
	m.radical_stroke = nil
	m.addradical_stroke = nil
}

// SetStroke sets the "stroke" field.
func (m *CharacterMutation) SetStroke(i int) {
	m.stroke = &i
	m.addstroke = nil
}

// Stroke returns the value of the "stroke" field in the mutation.
func (m *CharacterMutation) Stroke() (r int, exists bool) {
	v := m.stroke
	if v == nil {
		return
	}
	return *v, true
}

// OldStroke returns the old "stroke" field's value of the Character entity.
// If the Character object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharacterMutation) OldStroke(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStroke is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStroke requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStroke: %w", err)
	}
	return oldValue.Stroke, nil
}

// AddStroke adds i to the "stroke" field.
func (m *CharacterMutation) AddStroke(i int) {
	if m.addstroke != nil {
		*m.addstroke += i
	} else {
		m.addstroke = &i
	}
}

// AddedStroke returns the value that was added to the "stroke" field in this mutation.
func (m *CharacterMutation) AddedStroke() (r int, exists bool) {
	v := m.addstroke
	if v == nil {
		return
	}
	return *v, true
}

// ResetStroke resets all changes to the "stroke" field.
func (m *CharacterMutation) ResetStroke() {
	m.stroke = nil
	m.addstroke = nil
}

// SetIsKangXi sets the "is_kang_xi" field.
func (m *CharacterMutation) SetIsKangXi(b bool) {
	m.is_kang_xi = &b
}

// IsKangXi returns the value of the "is_kang_xi" field in the mutation.
func (m *CharacterMutation) IsKangXi() (r bool, exists bool) {
	v := m.is_kang_xi
	if v == nil {
		return
	}
	return *v, true
}

// OldIsKangXi returns the old "is_kang_xi" field's value of the Character entity.
// If the Character object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharacterMutation) OldIsKangXi(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsKangXi is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsKangXi requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsKangXi: %w", err)
	}
	return oldValue.IsKangXi, nil
}

// ResetIsKangXi resets all changes to the "is_kang_xi" field.
func (m *CharacterMutation) ResetIsKangXi() {
	m.is_kang_xi = nil
}

// SetKangXi sets the "kang_xi" field.
func (m *CharacterMutation) SetKangXi(s string) {
	m.kang_xi = &s
}

// KangXi returns the value of the "kang_xi" field in the mutation.
func (m *CharacterMutation) KangXi() (r string, exists bool) {
	v := m.kang_xi
	if v == nil {
		return
	}
	return *v, true
}

// OldKangXi returns the old "kang_xi" field's value of the Character entity.
// If the Character object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharacterMutation) OldKangXi(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKangXi is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKangXi requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKangXi: %w", err)
	}
	return oldValue.KangXi, nil
}

// ResetKangXi resets all changes to the "kang_xi" field.
func (m *CharacterMutation) ResetKangXi() {
	m.kang_xi = nil
}

// SetKangXiStroke sets the "kang_xi_stroke" field.
func (m *CharacterMutation) SetKangXiStroke(i int) {
	m.kang_xi_stroke = &i
	m.addkang_xi_stroke = nil
}

// KangXiStroke returns the value of the "kang_xi_stroke" field in the mutation.
func (m *CharacterMutation) KangXiStroke() (r int, exists bool) {
	v := m.kang_xi_stroke
	if v == nil {
		return
	}
	return *v, true
}

// OldKangXiStroke returns the old "kang_xi_stroke" field's value of the Character entity.
// If the Character object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharacterMutation) OldKangXiStroke(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKangXiStroke is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKangXiStroke requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKangXiStroke: %w", err)
	}
	return oldValue.KangXiStroke, nil
}

// AddKangXiStroke adds i to the "kang_xi_stroke" field.
func (m *CharacterMutation) AddKangXiStroke(i int) {
	if m.addkang_xi_stroke != nil {
		*m.addkang_xi_stroke += i
	} else {
		m.addkang_xi_stroke = &i
	}
}

// AddedKangXiStroke returns the value that was added to the "kang_xi_stroke" field in this mutation.
func (m *CharacterMutation) AddedKangXiStroke() (r int, exists bool) {
	v := m.addkang_xi_stroke
	if v == nil {
		return
	}
	return *v, true
}

// ResetKangXiStroke resets all changes to the "kang_xi_stroke" field.
func (m *CharacterMutation) ResetKangXiStroke() {
	m.kang_xi_stroke = nil
	m.addkang_xi_stroke = nil
}

// SetSimpleRadical sets the "simple_radical" field.
func (m *CharacterMutation) SetSimpleRadical(s string) {
	m.simple_radical = &s
}

// SimpleRadical returns the value of the "simple_radical" field in the mutation.
func (m *CharacterMutation) SimpleRadical() (r string, exists bool) {
	v := m.simple_radical
	if v == nil {
		return
	}
	return *v, true
}

// OldSimpleRadical returns the old "simple_radical" field's value of the Character entity.
// If the Character object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharacterMutation) OldSimpleRadical(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSimpleRadical is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSimpleRadical requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSimpleRadical: %w", err)
	}
	return oldValue.SimpleRadical, nil
}

// ResetSimpleRadical resets all changes to the "simple_radical" field.
func (m *CharacterMutation) ResetSimpleRadical() {
	m.simple_radical = nil
}

// SetSimpleRadicalStroke sets the "simple_radical_stroke" field.
func (m *CharacterMutation) SetSimpleRadicalStroke(i int) {
	m.simple_radical_stroke = &i
	m.addsimple_radical_stroke = nil
}

// SimpleRadicalStroke returns the value of the "simple_radical_stroke" field in the mutation.
func (m *CharacterMutation) SimpleRadicalStroke() (r int, exists bool) {
	v := m.simple_radical_stroke
	if v == nil {
		return
	}
	return *v, true
}

// OldSimpleRadicalStroke returns the old "simple_radical_stroke" field's value of the Character entity.
// If the Character object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharacterMutation) OldSimpleRadicalStroke(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSimpleRadicalStroke is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSimpleRadicalStroke requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSimpleRadicalStroke: %w", err)
	}
	return oldValue.SimpleRadicalStroke, nil
}

// AddSimpleRadicalStroke adds i to the "simple_radical_stroke" field.
func (m *CharacterMutation) AddSimpleRadicalStroke(i int) {
	if m.addsimple_radical_stroke != nil {
		*m.addsimple_radical_stroke += i
	} else {
		m.addsimple_radical_stroke = &i
	}
}

// AddedSimpleRadicalStroke returns the value that was added to the "simple_radical_stroke" field in this mutation.
func (m *CharacterMutation) AddedSimpleRadicalStroke() (r int, exists bool) {
	v := m.addsimple_radical_stroke
	if v == nil {
		return
	}
	return *v, true
}

// ResetSimpleRadicalStroke resets all changes to the "simple_radical_stroke" field.
func (m *CharacterMutation) ResetSimpleRadicalStroke() {
	m.simple_radical_stroke = nil
	m.addsimple_radical_stroke = nil
}

// SetSimpleTotalStroke sets the "simple_total_stroke" field.
func (m *CharacterMutation) SetSimpleTotalStroke(i int) {
	m.simple_total_stroke = &i
	m.addsimple_total_stroke = nil
}

// SimpleTotalStroke returns the value of the "simple_total_stroke" field in the mutation.
func (m *CharacterMutation) SimpleTotalStroke() (r int, exists bool) {
	v := m.simple_total_stroke
	if v == nil {
		return
	}
	return *v, true
}

// OldSimpleTotalStroke returns the old "simple_total_stroke" field's value of the Character entity.
// If the Character object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharacterMutation) OldSimpleTotalStroke(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSimpleTotalStroke is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSimpleTotalStroke requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSimpleTotalStroke: %w", err)
	}
	return oldValue.SimpleTotalStroke, nil
}

// AddSimpleTotalStroke adds i to the "simple_total_stroke" field.
func (m *CharacterMutation) AddSimpleTotalStroke(i int) {
	if m.addsimple_total_stroke != nil {
		*m.addsimple_total_stroke += i
	} else {
		m.addsimple_total_stroke = &i
	}
}

// AddedSimpleTotalStroke returns the value that was added to the "simple_total_stroke" field in this mutation.
func (m *CharacterMutation) AddedSimpleTotalStroke() (r int, exists bool) {
	v := m.addsimple_total_stroke
	if v == nil {
		return
	}
	return *v, true
}

// ResetSimpleTotalStroke resets all changes to the "simple_total_stroke" field.
func (m *CharacterMutation) ResetSimpleTotalStroke() {
	m.simple_total_stroke = nil
	m.addsimple_total_stroke = nil
}

// SetTraditionalRadical sets the "traditional_radical" field.
func (m *CharacterMutation) SetTraditionalRadical(s string) {
	m.traditional_radical = &s
}

// TraditionalRadical returns the value of the "traditional_radical" field in the mutation.
func (m *CharacterMutation) TraditionalRadical() (r string, exists bool) {
	v := m.traditional_radical
	if v == nil {
		return
	}
	return *v, true
}

// OldTraditionalRadical returns the old "traditional_radical" field's value of the Character entity.
// If the Character object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharacterMutation) OldTraditionalRadical(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTraditionalRadical is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTraditionalRadical requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTraditionalRadical: %w", err)
	}
	return oldValue.TraditionalRadical, nil
}

// ResetTraditionalRadical resets all changes to the "traditional_radical" field.
func (m *CharacterMutation) ResetTraditionalRadical() {
	m.traditional_radical = nil
}

// SetTraditionalRadicalStroke sets the "traditional_radical_stroke" field.
func (m *CharacterMutation) SetTraditionalRadicalStroke(i int) {
	m.traditional_radical_stroke = &i
	m.addtraditional_radical_stroke = nil
}

// TraditionalRadicalStroke returns the value of the "traditional_radical_stroke" field in the mutation.
func (m *CharacterMutation) TraditionalRadicalStroke() (r int, exists bool) {
	v := m.traditional_radical_stroke
	if v == nil {
		return
	}
	return *v, true
}

// OldTraditionalRadicalStroke returns the old "traditional_radical_stroke" field's value of the Character entity.
// If the Character object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharacterMutation) OldTraditionalRadicalStroke(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTraditionalRadicalStroke is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTraditionalRadicalStroke requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTraditionalRadicalStroke: %w", err)
	}
	return oldValue.TraditionalRadicalStroke, nil
}

// AddTraditionalRadicalStroke adds i to the "traditional_radical_stroke" field.
func (m *CharacterMutation) AddTraditionalRadicalStroke(i int) {
	if m.addtraditional_radical_stroke != nil {
		*m.addtraditional_radical_stroke += i
	} else {
		m.addtraditional_radical_stroke = &i
	}
}

// AddedTraditionalRadicalStroke returns the value that was added to the "traditional_radical_stroke" field in this mutation.
func (m *CharacterMutation) AddedTraditionalRadicalStroke() (r int, exists bool) {
	v := m.addtraditional_radical_stroke
	if v == nil {
		return
	}
	return *v, true
}

// ResetTraditionalRadicalStroke resets all changes to the "traditional_radical_stroke" field.
func (m *CharacterMutation) ResetTraditionalRadicalStroke() {
	m.traditional_radical_stroke = nil
	m.addtraditional_radical_stroke = nil
}

// SetTraditionalTotalStroke sets the "traditional_total_stroke" field.
func (m *CharacterMutation) SetTraditionalTotalStroke(i int) {
	m.traditional_total_stroke = &i
	m.addtraditional_total_stroke = nil
}

// TraditionalTotalStroke returns the value of the "traditional_total_stroke" field in the mutation.
func (m *CharacterMutation) TraditionalTotalStroke() (r int, exists bool) {
	v := m.traditional_total_stroke
	if v == nil {
		return
	}
	return *v, true
}

// OldTraditionalTotalStroke returns the old "traditional_total_stroke" field's value of the Character entity.
// If the Character object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharacterMutation) OldTraditionalTotalStroke(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTraditionalTotalStroke is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTraditionalTotalStroke requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTraditionalTotalStroke: %w", err)
	}
	return oldValue.TraditionalTotalStroke, nil
}

// AddTraditionalTotalStroke adds i to the "traditional_total_stroke" field.
func (m *CharacterMutation) AddTraditionalTotalStroke(i int) {
	if m.addtraditional_total_stroke != nil {
		*m.addtraditional_total_stroke += i
	} else {
		m.addtraditional_total_stroke = &i
	}
}

// AddedTraditionalTotalStroke returns the value that was added to the "traditional_total_stroke" field in this mutation.
func (m *CharacterMutation) AddedTraditionalTotalStroke() (r int, exists bool) {
	v := m.addtraditional_total_stroke
	if v == nil {
		return
	}
	return *v, true
}

// ResetTraditionalTotalStroke resets all changes to the "traditional_total_stroke" field.
func (m *CharacterMutation) ResetTraditionalTotalStroke() {
	m.traditional_total_stroke = nil
	m.addtraditional_total_stroke = nil
}

// SetNameScience sets the "name_science" field.
func (m *CharacterMutation) SetNameScience(b bool) {
	m.name_science = &b
}

// NameScience returns the value of the "name_science" field in the mutation.
func (m *CharacterMutation) NameScience() (r bool, exists bool) {
	v := m.name_science
	if v == nil {
		return
	}
	return *v, true
}

// OldNameScience returns the old "name_science" field's value of the Character entity.
// If the Character object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharacterMutation) OldNameScience(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNameScience is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNameScience requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNameScience: %w", err)
	}
	return oldValue.NameScience, nil
}

// ResetNameScience resets all changes to the "name_science" field.
func (m *CharacterMutation) ResetNameScience() {
	m.name_science = nil
}

// SetWuXing sets the "wu_xing" field.
func (m *CharacterMutation) SetWuXing(s string) {
	m.wu_xing = &s
}

// WuXing returns the value of the "wu_xing" field in the mutation.
func (m *CharacterMutation) WuXing() (r string, exists bool) {
	v := m.wu_xing
	if v == nil {
		return
	}
	return *v, true
}

// OldWuXing returns the old "wu_xing" field's value of the Character entity.
// If the Character object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharacterMutation) OldWuXing(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWuXing is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWuXing requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWuXing: %w", err)
	}
	return oldValue.WuXing, nil
}

// ResetWuXing resets all changes to the "wu_xing" field.
func (m *CharacterMutation) ResetWuXing() {
	m.wu_xing = nil
}

// SetLucky sets the "lucky" field.
func (m *CharacterMutation) SetLucky(s string) {
	m.lucky = &s
}

// Lucky returns the value of the "lucky" field in the mutation.
func (m *CharacterMutation) Lucky() (r string, exists bool) {
	v := m.lucky
	if v == nil {
		return
	}
	return *v, true
}

// OldLucky returns the old "lucky" field's value of the Character entity.
// If the Character object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharacterMutation) OldLucky(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLucky is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLucky requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLucky: %w", err)
	}
	return oldValue.Lucky, nil
}

// ResetLucky resets all changes to the "lucky" field.
func (m *CharacterMutation) ResetLucky() {
	m.lucky = nil
}

// SetRegular sets the "regular" field.
func (m *CharacterMutation) SetRegular(b bool) {
	m.regular = &b
}

// Regular returns the value of the "regular" field in the mutation.
func (m *CharacterMutation) Regular() (r bool, exists bool) {
	v := m.regular
	if v == nil {
		return
	}
	return *v, true
}

// OldRegular returns the old "regular" field's value of the Character entity.
// If the Character object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharacterMutation) OldRegular(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRegular is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRegular requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegular: %w", err)
	}
	return oldValue.Regular, nil
}

// ResetRegular resets all changes to the "regular" field.
func (m *CharacterMutation) ResetRegular() {
	m.regular = nil
}

// SetTraditionalCharacter sets the "traditional_character" field.
func (m *CharacterMutation) SetTraditionalCharacter(s []string) {
	m.traditional_character = &s
	m.appendtraditional_character = nil
}

// TraditionalCharacter returns the value of the "traditional_character" field in the mutation.
func (m *CharacterMutation) TraditionalCharacter() (r []string, exists bool) {
	v := m.traditional_character
	if v == nil {
		return
	}
	return *v, true
}

// OldTraditionalCharacter returns the old "traditional_character" field's value of the Character entity.
// If the Character object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharacterMutation) OldTraditionalCharacter(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTraditionalCharacter is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTraditionalCharacter requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTraditionalCharacter: %w", err)
	}
	return oldValue.TraditionalCharacter, nil
}

// AppendTraditionalCharacter adds s to the "traditional_character" field.
func (m *CharacterMutation) AppendTraditionalCharacter(s []string) {
	m.appendtraditional_character = append(m.appendtraditional_character, s...)
}

// AppendedTraditionalCharacter returns the list of values that were appended to the "traditional_character" field in this mutation.
func (m *CharacterMutation) AppendedTraditionalCharacter() ([]string, bool) {
	if len(m.appendtraditional_character) == 0 {
		return nil, false
	}
	return m.appendtraditional_character, true
}

// ResetTraditionalCharacter resets all changes to the "traditional_character" field.
func (m *CharacterMutation) ResetTraditionalCharacter() {
	m.traditional_character = nil
	m.appendtraditional_character = nil
}

// SetVariantCharacter sets the "variant_character" field.
func (m *CharacterMutation) SetVariantCharacter(s []string) {
	m.variant_character = &s
	m.appendvariant_character = nil
}

// VariantCharacter returns the value of the "variant_character" field in the mutation.
func (m *CharacterMutation) VariantCharacter() (r []string, exists bool) {
	v := m.variant_character
	if v == nil {
		return
	}
	return *v, true
}

// OldVariantCharacter returns the old "variant_character" field's value of the Character entity.
// If the Character object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharacterMutation) OldVariantCharacter(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVariantCharacter is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVariantCharacter requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVariantCharacter: %w", err)
	}
	return oldValue.VariantCharacter, nil
}

// AppendVariantCharacter adds s to the "variant_character" field.
func (m *CharacterMutation) AppendVariantCharacter(s []string) {
	m.appendvariant_character = append(m.appendvariant_character, s...)
}

// AppendedVariantCharacter returns the list of values that were appended to the "variant_character" field in this mutation.
func (m *CharacterMutation) AppendedVariantCharacter() ([]string, bool) {
	if len(m.appendvariant_character) == 0 {
		return nil, false
	}
	return m.appendvariant_character, true
}

// ResetVariantCharacter resets all changes to the "variant_character" field.
func (m *CharacterMutation) ResetVariantCharacter() {
	m.variant_character = nil
	m.appendvariant_character = nil
}

// SetComment sets the "comment" field.
func (m *CharacterMutation) SetComment(s []string) {
	m.comment = &s
	m.appendcomment = nil
}

// Comment returns the value of the "comment" field in the mutation.
func (m *CharacterMutation) Comment() (r []string, exists bool) {
	v := m.comment
	if v == nil {
		return
	}
	return *v, true
}

// OldComment returns the old "comment" field's value of the Character entity.
// If the Character object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharacterMutation) OldComment(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldComment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldComment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComment: %w", err)
	}
	return oldValue.Comment, nil
}

// AppendComment adds s to the "comment" field.
func (m *CharacterMutation) AppendComment(s []string) {
	m.appendcomment = append(m.appendcomment, s...)
}

// AppendedComment returns the list of values that were appended to the "comment" field in this mutation.
func (m *CharacterMutation) AppendedComment() ([]string, bool) {
	if len(m.appendcomment) == 0 {
		return nil, false
	}
	return m.appendcomment, true
}

// ResetComment resets all changes to the "comment" field.
func (m *CharacterMutation) ResetComment() {
	m.comment = nil
	m.appendcomment = nil
}

// SetScienceStroke sets the "science_stroke" field.
func (m *CharacterMutation) SetScienceStroke(i int) {
	m.science_stroke = &i
	m.addscience_stroke = nil
}

// ScienceStroke returns the value of the "science_stroke" field in the mutation.
func (m *CharacterMutation) ScienceStroke() (r int, exists bool) {
	v := m.science_stroke
	if v == nil {
		return
	}
	return *v, true
}

// OldScienceStroke returns the old "science_stroke" field's value of the Character entity.
// If the Character object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharacterMutation) OldScienceStroke(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScienceStroke is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScienceStroke requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScienceStroke: %w", err)
	}
	return oldValue.ScienceStroke, nil
}

// AddScienceStroke adds i to the "science_stroke" field.
func (m *CharacterMutation) AddScienceStroke(i int) {
	if m.addscience_stroke != nil {
		*m.addscience_stroke += i
	} else {
		m.addscience_stroke = &i
	}
}

// AddedScienceStroke returns the value that was added to the "science_stroke" field in this mutation.
func (m *CharacterMutation) AddedScienceStroke() (r int, exists bool) {
	v := m.addscience_stroke
	if v == nil {
		return
	}
	return *v, true
}

// ResetScienceStroke resets all changes to the "science_stroke" field.
func (m *CharacterMutation) ResetScienceStroke() {
	m.science_stroke = nil
	m.addscience_stroke = nil
}

// Where appends a list predicates to the CharacterMutation builder.
func (m *CharacterMutation) Where(ps ...predicate.Character) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CharacterMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CharacterMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Character, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CharacterMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CharacterMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Character).
func (m *CharacterMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CharacterMutation) Fields() []string {
	fields := make([]string, 0, 22)
	if m.pin_yin != nil {
		fields = append(fields, character.FieldPinYin)
	}
	if m.ch != nil {
		fields = append(fields, character.FieldCh)
	}
	if m.radical != nil {
		fields = append(fields, character.FieldRadical)
	}
	if m.radical_stroke != nil {
		fields = append(fields, character.FieldRadicalStroke)
	}
	if m.stroke != nil {
		fields = append(fields, character.FieldStroke)
	}
	if m.is_kang_xi != nil {
		fields = append(fields, character.FieldIsKangXi)
	}
	if m.kang_xi != nil {
		fields = append(fields, character.FieldKangXi)
	}
	if m.kang_xi_stroke != nil {
		fields = append(fields, character.FieldKangXiStroke)
	}
	if m.simple_radical != nil {
		fields = append(fields, character.FieldSimpleRadical)
	}
	if m.simple_radical_stroke != nil {
		fields = append(fields, character.FieldSimpleRadicalStroke)
	}
	if m.simple_total_stroke != nil {
		fields = append(fields, character.FieldSimpleTotalStroke)
	}
	if m.traditional_radical != nil {
		fields = append(fields, character.FieldTraditionalRadical)
	}
	if m.traditional_radical_stroke != nil {
		fields = append(fields, character.FieldTraditionalRadicalStroke)
	}
	if m.traditional_total_stroke != nil {
		fields = append(fields, character.FieldTraditionalTotalStroke)
	}
	if m.name_science != nil {
		fields = append(fields, character.FieldNameScience)
	}
	if m.wu_xing != nil {
		fields = append(fields, character.FieldWuXing)
	}
	if m.lucky != nil {
		fields = append(fields, character.FieldLucky)
	}
	if m.regular != nil {
		fields = append(fields, character.FieldRegular)
	}
	if m.traditional_character != nil {
		fields = append(fields, character.FieldTraditionalCharacter)
	}
	if m.variant_character != nil {
		fields = append(fields, character.FieldVariantCharacter)
	}
	if m.comment != nil {
		fields = append(fields, character.FieldComment)
	}
	if m.science_stroke != nil {
		fields = append(fields, character.FieldScienceStroke)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CharacterMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case character.FieldPinYin:
		return m.PinYin()
	case character.FieldCh:
		return m.Ch()
	case character.FieldRadical:
		return m.Radical()
	case character.FieldRadicalStroke:
		return m.RadicalStroke()
	case character.FieldStroke:
		return m.Stroke()
	case character.FieldIsKangXi:
		return m.IsKangXi()
	case character.FieldKangXi:
		return m.KangXi()
	case character.FieldKangXiStroke:
		return m.KangXiStroke()
	case character.FieldSimpleRadical:
		return m.SimpleRadical()
	case character.FieldSimpleRadicalStroke:
		return m.SimpleRadicalStroke()
	case character.FieldSimpleTotalStroke:
		return m.SimpleTotalStroke()
	case character.FieldTraditionalRadical:
		return m.TraditionalRadical()
	case character.FieldTraditionalRadicalStroke:
		return m.TraditionalRadicalStroke()
	case character.FieldTraditionalTotalStroke:
		return m.TraditionalTotalStroke()
	case character.FieldNameScience:
		return m.NameScience()
	case character.FieldWuXing:
		return m.WuXing()
	case character.FieldLucky:
		return m.Lucky()
	case character.FieldRegular:
		return m.Regular()
	case character.FieldTraditionalCharacter:
		return m.TraditionalCharacter()
	case character.FieldVariantCharacter:
		return m.VariantCharacter()
	case character.FieldComment:
		return m.Comment()
	case character.FieldScienceStroke:
		return m.ScienceStroke()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CharacterMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case character.FieldPinYin:
		return m.OldPinYin(ctx)
	case character.FieldCh:
		return m.OldCh(ctx)
	case character.FieldRadical:
		return m.OldRadical(ctx)
	case character.FieldRadicalStroke:
		return m.OldRadicalStroke(ctx)
	case character.FieldStroke:
		return m.OldStroke(ctx)
	case character.FieldIsKangXi:
		return m.OldIsKangXi(ctx)
	case character.FieldKangXi:
		return m.OldKangXi(ctx)
	case character.FieldKangXiStroke:
		return m.OldKangXiStroke(ctx)
	case character.FieldSimpleRadical:
		return m.OldSimpleRadical(ctx)
	case character.FieldSimpleRadicalStroke:
		return m.OldSimpleRadicalStroke(ctx)
	case character.FieldSimpleTotalStroke:
		return m.OldSimpleTotalStroke(ctx)
	case character.FieldTraditionalRadical:
		return m.OldTraditionalRadical(ctx)
	case character.FieldTraditionalRadicalStroke:
		return m.OldTraditionalRadicalStroke(ctx)
	case character.FieldTraditionalTotalStroke:
		return m.OldTraditionalTotalStroke(ctx)
	case character.FieldNameScience:
		return m.OldNameScience(ctx)
	case character.FieldWuXing:
		return m.OldWuXing(ctx)
	case character.FieldLucky:
		return m.OldLucky(ctx)
	case character.FieldRegular:
		return m.OldRegular(ctx)
	case character.FieldTraditionalCharacter:
		return m.OldTraditionalCharacter(ctx)
	case character.FieldVariantCharacter:
		return m.OldVariantCharacter(ctx)
	case character.FieldComment:
		return m.OldComment(ctx)
	case character.FieldScienceStroke:
		return m.OldScienceStroke(ctx)
	}
	return nil, fmt.Errorf("unknown Character field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CharacterMutation) SetField(name string, value ent.Value) error {
	switch name {
	case character.FieldPinYin:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPinYin(v)
		return nil
	case character.FieldCh:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCh(v)
		return nil
	case character.FieldRadical:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRadical(v)
		return nil
	case character.FieldRadicalStroke:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRadicalStroke(v)
		return nil
	case character.FieldStroke:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStroke(v)
		return nil
	case character.FieldIsKangXi:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsKangXi(v)
		return nil
	case character.FieldKangXi:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKangXi(v)
		return nil
	case character.FieldKangXiStroke:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKangXiStroke(v)
		return nil
	case character.FieldSimpleRadical:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSimpleRadical(v)
		return nil
	case character.FieldSimpleRadicalStroke:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSimpleRadicalStroke(v)
		return nil
	case character.FieldSimpleTotalStroke:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSimpleTotalStroke(v)
		return nil
	case character.FieldTraditionalRadical:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTraditionalRadical(v)
		return nil
	case character.FieldTraditionalRadicalStroke:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTraditionalRadicalStroke(v)
		return nil
	case character.FieldTraditionalTotalStroke:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTraditionalTotalStroke(v)
		return nil
	case character.FieldNameScience:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNameScience(v)
		return nil
	case character.FieldWuXing:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWuXing(v)
		return nil
	case character.FieldLucky:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLucky(v)
		return nil
	case character.FieldRegular:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegular(v)
		return nil
	case character.FieldTraditionalCharacter:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTraditionalCharacter(v)
		return nil
	case character.FieldVariantCharacter:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVariantCharacter(v)
		return nil
	case character.FieldComment:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComment(v)
		return nil
	case character.FieldScienceStroke:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScienceStroke(v)
		return nil
	}
	return fmt.Errorf("unknown Character field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CharacterMutation) AddedFields() []string {
	var fields []string
	if m.addradical_stroke != nil {
		fields = append(fields, character.FieldRadicalStroke)
	}
	if m.addstroke != nil {
		fields = append(fields, character.FieldStroke)
	}
	if m.addkang_xi_stroke != nil {
		fields = append(fields, character.FieldKangXiStroke)
	}
	if m.addsimple_radical_stroke != nil {
		fields = append(fields, character.FieldSimpleRadicalStroke)
	}
	if m.addsimple_total_stroke != nil {
		fields = append(fields, character.FieldSimpleTotalStroke)
	}
	if m.addtraditional_radical_stroke != nil {
		fields = append(fields, character.FieldTraditionalRadicalStroke)
	}
	if m.addtraditional_total_stroke != nil {
		fields = append(fields, character.FieldTraditionalTotalStroke)
	}
	if m.addscience_stroke != nil {
		fields = append(fields, character.FieldScienceStroke)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CharacterMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case character.FieldRadicalStroke:
		return m.AddedRadicalStroke()
	case character.FieldStroke:
		return m.AddedStroke()
	case character.FieldKangXiStroke:
		return m.AddedKangXiStroke()
	case character.FieldSimpleRadicalStroke:
		return m.AddedSimpleRadicalStroke()
	case character.FieldSimpleTotalStroke:
		return m.AddedSimpleTotalStroke()
	case character.FieldTraditionalRadicalStroke:
		return m.AddedTraditionalRadicalStroke()
	case character.FieldTraditionalTotalStroke:
		return m.AddedTraditionalTotalStroke()
	case character.FieldScienceStroke:
		return m.AddedScienceStroke()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CharacterMutation) AddField(name string, value ent.Value) error {
	switch name {
	case character.FieldRadicalStroke:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRadicalStroke(v)
		return nil
	case character.FieldStroke:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStroke(v)
		return nil
	case character.FieldKangXiStroke:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddKangXiStroke(v)
		return nil
	case character.FieldSimpleRadicalStroke:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSimpleRadicalStroke(v)
		return nil
	case character.FieldSimpleTotalStroke:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSimpleTotalStroke(v)
		return nil
	case character.FieldTraditionalRadicalStroke:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTraditionalRadicalStroke(v)
		return nil
	case character.FieldTraditionalTotalStroke:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTraditionalTotalStroke(v)
		return nil
	case character.FieldScienceStroke:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddScienceStroke(v)
		return nil
	}
	return fmt.Errorf("unknown Character numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CharacterMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CharacterMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CharacterMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Character nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CharacterMutation) ResetField(name string) error {
	switch name {
	case character.FieldPinYin:
		m.ResetPinYin()
		return nil
	case character.FieldCh:
		m.ResetCh()
		return nil
	case character.FieldRadical:
		m.ResetRadical()
		return nil
	case character.FieldRadicalStroke:
		m.ResetRadicalStroke()
		return nil
	case character.FieldStroke:
		m.ResetStroke()
		return nil
	case character.FieldIsKangXi:
		m.ResetIsKangXi()
		return nil
	case character.FieldKangXi:
		m.ResetKangXi()
		return nil
	case character.FieldKangXiStroke:
		m.ResetKangXiStroke()
		return nil
	case character.FieldSimpleRadical:
		m.ResetSimpleRadical()
		return nil
	case character.FieldSimpleRadicalStroke:
		m.ResetSimpleRadicalStroke()
		return nil
	case character.FieldSimpleTotalStroke:
		m.ResetSimpleTotalStroke()
		return nil
	case character.FieldTraditionalRadical:
		m.ResetTraditionalRadical()
		return nil
	case character.FieldTraditionalRadicalStroke:
		m.ResetTraditionalRadicalStroke()
		return nil
	case character.FieldTraditionalTotalStroke:
		m.ResetTraditionalTotalStroke()
		return nil
	case character.FieldNameScience:
		m.ResetNameScience()
		return nil
	case character.FieldWuXing:
		m.ResetWuXing()
		return nil
	case character.FieldLucky:
		m.ResetLucky()
		return nil
	case character.FieldRegular:
		m.ResetRegular()
		return nil
	case character.FieldTraditionalCharacter:
		m.ResetTraditionalCharacter()
		return nil
	case character.FieldVariantCharacter:
		m.ResetVariantCharacter()
		return nil
	case character.FieldComment:
		m.ResetComment()
		return nil
	case character.FieldScienceStroke:
		m.ResetScienceStroke()
		return nil
	}
	return fmt.Errorf("unknown Character field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CharacterMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CharacterMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CharacterMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CharacterMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CharacterMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CharacterMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CharacterMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Character unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CharacterMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Character edge %s", name)
}

// IdiomMutation represents an operation that mutates the Idiom nodes in the graph.
type IdiomMutation struct {
	config
	op              Op
	typ             string
	id              *int32
	pin_yin         *[]string
	appendpin_yin   []string
	word            *string
	derivation      *int
	addderivation   *int
	explanation     *string
	abbreviation    *int
	addabbreviation *int
	example         *string
	comment         *string
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*Idiom, error)
	predicates      []predicate.Idiom
}

var _ ent.Mutation = (*IdiomMutation)(nil)

// idiomOption allows management of the mutation configuration using functional options.
type idiomOption func(*IdiomMutation)

// newIdiomMutation creates new mutation for the Idiom entity.
func newIdiomMutation(c config, op Op, opts ...idiomOption) *IdiomMutation {
	m := &IdiomMutation{
		config:        c,
		op:            op,
		typ:           TypeIdiom,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withIdiomID sets the ID field of the mutation.
func withIdiomID(id int32) idiomOption {
	return func(m *IdiomMutation) {
		var (
			err   error
			once  sync.Once
			value *Idiom
		)
		m.oldValue = func(ctx context.Context) (*Idiom, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Idiom.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withIdiom sets the old Idiom of the mutation.
func withIdiom(node *Idiom) idiomOption {
	return func(m *IdiomMutation) {
		m.oldValue = func(context.Context) (*Idiom, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m IdiomMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m IdiomMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Idiom entities.
func (m *IdiomMutation) SetID(id int32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *IdiomMutation) ID() (id int32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *IdiomMutation) IDs(ctx context.Context) ([]int32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Idiom.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPinYin sets the "pin_yin" field.
func (m *IdiomMutation) SetPinYin(s []string) {
	m.pin_yin = &s
	m.appendpin_yin = nil
}

// PinYin returns the value of the "pin_yin" field in the mutation.
func (m *IdiomMutation) PinYin() (r []string, exists bool) {
	v := m.pin_yin
	if v == nil {
		return
	}
	return *v, true
}

// OldPinYin returns the old "pin_yin" field's value of the Idiom entity.
// If the Idiom object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdiomMutation) OldPinYin(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPinYin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPinYin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPinYin: %w", err)
	}
	return oldValue.PinYin, nil
}

// AppendPinYin adds s to the "pin_yin" field.
func (m *IdiomMutation) AppendPinYin(s []string) {
	m.appendpin_yin = append(m.appendpin_yin, s...)
}

// AppendedPinYin returns the list of values that were appended to the "pin_yin" field in this mutation.
func (m *IdiomMutation) AppendedPinYin() ([]string, bool) {
	if len(m.appendpin_yin) == 0 {
		return nil, false
	}
	return m.appendpin_yin, true
}

// ResetPinYin resets all changes to the "pin_yin" field.
func (m *IdiomMutation) ResetPinYin() {
	m.pin_yin = nil
	m.appendpin_yin = nil
}

// SetWord sets the "word" field.
func (m *IdiomMutation) SetWord(s string) {
	m.word = &s
}

// Word returns the value of the "word" field in the mutation.
func (m *IdiomMutation) Word() (r string, exists bool) {
	v := m.word
	if v == nil {
		return
	}
	return *v, true
}

// OldWord returns the old "word" field's value of the Idiom entity.
// If the Idiom object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdiomMutation) OldWord(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWord is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWord requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWord: %w", err)
	}
	return oldValue.Word, nil
}

// ResetWord resets all changes to the "word" field.
func (m *IdiomMutation) ResetWord() {
	m.word = nil
}

// SetDerivation sets the "derivation" field.
func (m *IdiomMutation) SetDerivation(i int) {
	m.derivation = &i
	m.addderivation = nil
}

// Derivation returns the value of the "derivation" field in the mutation.
func (m *IdiomMutation) Derivation() (r int, exists bool) {
	v := m.derivation
	if v == nil {
		return
	}
	return *v, true
}

// OldDerivation returns the old "derivation" field's value of the Idiom entity.
// If the Idiom object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdiomMutation) OldDerivation(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDerivation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDerivation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDerivation: %w", err)
	}
	return oldValue.Derivation, nil
}

// AddDerivation adds i to the "derivation" field.
func (m *IdiomMutation) AddDerivation(i int) {
	if m.addderivation != nil {
		*m.addderivation += i
	} else {
		m.addderivation = &i
	}
}

// AddedDerivation returns the value that was added to the "derivation" field in this mutation.
func (m *IdiomMutation) AddedDerivation() (r int, exists bool) {
	v := m.addderivation
	if v == nil {
		return
	}
	return *v, true
}

// ResetDerivation resets all changes to the "derivation" field.
func (m *IdiomMutation) ResetDerivation() {
	m.derivation = nil
	m.addderivation = nil
}

// SetExplanation sets the "explanation" field.
func (m *IdiomMutation) SetExplanation(s string) {
	m.explanation = &s
}

// Explanation returns the value of the "explanation" field in the mutation.
func (m *IdiomMutation) Explanation() (r string, exists bool) {
	v := m.explanation
	if v == nil {
		return
	}
	return *v, true
}

// OldExplanation returns the old "explanation" field's value of the Idiom entity.
// If the Idiom object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdiomMutation) OldExplanation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExplanation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExplanation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExplanation: %w", err)
	}
	return oldValue.Explanation, nil
}

// ResetExplanation resets all changes to the "explanation" field.
func (m *IdiomMutation) ResetExplanation() {
	m.explanation = nil
}

// SetAbbreviation sets the "abbreviation" field.
func (m *IdiomMutation) SetAbbreviation(i int) {
	m.abbreviation = &i
	m.addabbreviation = nil
}

// Abbreviation returns the value of the "abbreviation" field in the mutation.
func (m *IdiomMutation) Abbreviation() (r int, exists bool) {
	v := m.abbreviation
	if v == nil {
		return
	}
	return *v, true
}

// OldAbbreviation returns the old "abbreviation" field's value of the Idiom entity.
// If the Idiom object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdiomMutation) OldAbbreviation(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAbbreviation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAbbreviation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAbbreviation: %w", err)
	}
	return oldValue.Abbreviation, nil
}

// AddAbbreviation adds i to the "abbreviation" field.
func (m *IdiomMutation) AddAbbreviation(i int) {
	if m.addabbreviation != nil {
		*m.addabbreviation += i
	} else {
		m.addabbreviation = &i
	}
}

// AddedAbbreviation returns the value that was added to the "abbreviation" field in this mutation.
func (m *IdiomMutation) AddedAbbreviation() (r int, exists bool) {
	v := m.addabbreviation
	if v == nil {
		return
	}
	return *v, true
}

// ResetAbbreviation resets all changes to the "abbreviation" field.
func (m *IdiomMutation) ResetAbbreviation() {
	m.abbreviation = nil
	m.addabbreviation = nil
}

// SetExample sets the "example" field.
func (m *IdiomMutation) SetExample(s string) {
	m.example = &s
}

// Example returns the value of the "example" field in the mutation.
func (m *IdiomMutation) Example() (r string, exists bool) {
	v := m.example
	if v == nil {
		return
	}
	return *v, true
}

// OldExample returns the old "example" field's value of the Idiom entity.
// If the Idiom object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdiomMutation) OldExample(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExample is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExample requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExample: %w", err)
	}
	return oldValue.Example, nil
}

// ResetExample resets all changes to the "example" field.
func (m *IdiomMutation) ResetExample() {
	m.example = nil
}

// SetComment sets the "comment" field.
func (m *IdiomMutation) SetComment(s string) {
	m.comment = &s
}

// Comment returns the value of the "comment" field in the mutation.
func (m *IdiomMutation) Comment() (r string, exists bool) {
	v := m.comment
	if v == nil {
		return
	}
	return *v, true
}

// OldComment returns the old "comment" field's value of the Idiom entity.
// If the Idiom object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdiomMutation) OldComment(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldComment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldComment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComment: %w", err)
	}
	return oldValue.Comment, nil
}

// ResetComment resets all changes to the "comment" field.
func (m *IdiomMutation) ResetComment() {
	m.comment = nil
}

// Where appends a list predicates to the IdiomMutation builder.
func (m *IdiomMutation) Where(ps ...predicate.Idiom) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the IdiomMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *IdiomMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Idiom, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *IdiomMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *IdiomMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Idiom).
func (m *IdiomMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *IdiomMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.pin_yin != nil {
		fields = append(fields, idiom.FieldPinYin)
	}
	if m.word != nil {
		fields = append(fields, idiom.FieldWord)
	}
	if m.derivation != nil {
		fields = append(fields, idiom.FieldDerivation)
	}
	if m.explanation != nil {
		fields = append(fields, idiom.FieldExplanation)
	}
	if m.abbreviation != nil {
		fields = append(fields, idiom.FieldAbbreviation)
	}
	if m.example != nil {
		fields = append(fields, idiom.FieldExample)
	}
	if m.comment != nil {
		fields = append(fields, idiom.FieldComment)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *IdiomMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case idiom.FieldPinYin:
		return m.PinYin()
	case idiom.FieldWord:
		return m.Word()
	case idiom.FieldDerivation:
		return m.Derivation()
	case idiom.FieldExplanation:
		return m.Explanation()
	case idiom.FieldAbbreviation:
		return m.Abbreviation()
	case idiom.FieldExample:
		return m.Example()
	case idiom.FieldComment:
		return m.Comment()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *IdiomMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case idiom.FieldPinYin:
		return m.OldPinYin(ctx)
	case idiom.FieldWord:
		return m.OldWord(ctx)
	case idiom.FieldDerivation:
		return m.OldDerivation(ctx)
	case idiom.FieldExplanation:
		return m.OldExplanation(ctx)
	case idiom.FieldAbbreviation:
		return m.OldAbbreviation(ctx)
	case idiom.FieldExample:
		return m.OldExample(ctx)
	case idiom.FieldComment:
		return m.OldComment(ctx)
	}
	return nil, fmt.Errorf("unknown Idiom field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IdiomMutation) SetField(name string, value ent.Value) error {
	switch name {
	case idiom.FieldPinYin:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPinYin(v)
		return nil
	case idiom.FieldWord:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWord(v)
		return nil
	case idiom.FieldDerivation:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDerivation(v)
		return nil
	case idiom.FieldExplanation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExplanation(v)
		return nil
	case idiom.FieldAbbreviation:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAbbreviation(v)
		return nil
	case idiom.FieldExample:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExample(v)
		return nil
	case idiom.FieldComment:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComment(v)
		return nil
	}
	return fmt.Errorf("unknown Idiom field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *IdiomMutation) AddedFields() []string {
	var fields []string
	if m.addderivation != nil {
		fields = append(fields, idiom.FieldDerivation)
	}
	if m.addabbreviation != nil {
		fields = append(fields, idiom.FieldAbbreviation)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *IdiomMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case idiom.FieldDerivation:
		return m.AddedDerivation()
	case idiom.FieldAbbreviation:
		return m.AddedAbbreviation()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IdiomMutation) AddField(name string, value ent.Value) error {
	switch name {
	case idiom.FieldDerivation:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDerivation(v)
		return nil
	case idiom.FieldAbbreviation:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAbbreviation(v)
		return nil
	}
	return fmt.Errorf("unknown Idiom numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *IdiomMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *IdiomMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *IdiomMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Idiom nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *IdiomMutation) ResetField(name string) error {
	switch name {
	case idiom.FieldPinYin:
		m.ResetPinYin()
		return nil
	case idiom.FieldWord:
		m.ResetWord()
		return nil
	case idiom.FieldDerivation:
		m.ResetDerivation()
		return nil
	case idiom.FieldExplanation:
		m.ResetExplanation()
		return nil
	case idiom.FieldAbbreviation:
		m.ResetAbbreviation()
		return nil
	case idiom.FieldExample:
		m.ResetExample()
		return nil
	case idiom.FieldComment:
		m.ResetComment()
		return nil
	}
	return fmt.Errorf("unknown Idiom field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *IdiomMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *IdiomMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *IdiomMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *IdiomMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *IdiomMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *IdiomMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *IdiomMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Idiom unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *IdiomMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Idiom edge %s", name)
}

// NCharacterMutation represents an operation that mutates the NCharacter nodes in the graph.
type NCharacterMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	pin_yin              *[]string
	appendpin_yin        []string
	char                 *string
	char_stroke          *int
	addchar_stroke       *int
	radical              *string
	radical_stroke       *int
	addradical_stroke    *int
	is_regular           *bool
	is_simplified        *bool
	simplified_id        *[]int
	appendsimplified_id  []int
	is_traditional       *bool
	traditional_id       *[]int
	appendtraditional_id []int
	is_kang_xi           *bool
	kang_xi_id           *[]int
	appendkang_xi_id     []int
	kang_xi_stroke       *int
	addkang_xi_stroke    *int
	is_variant           *bool
	variant_id           *[]int
	appendvariant_id     []int
	is_science           *bool
	science_stroke       *int
	addscience_stroke    *int
	wu_xing              *string
	lucky                *string
	explanation          *string
	comment              *[]string
	appendcomment        []string
	need_fix             *bool
	clearedFields        map[string]struct{}
	done                 bool
	oldValue             func(context.Context) (*NCharacter, error)
	predicates           []predicate.NCharacter
}

var _ ent.Mutation = (*NCharacterMutation)(nil)

// ncharacterOption allows management of the mutation configuration using functional options.
type ncharacterOption func(*NCharacterMutation)

// newNCharacterMutation creates new mutation for the NCharacter entity.
func newNCharacterMutation(c config, op Op, opts ...ncharacterOption) *NCharacterMutation {
	m := &NCharacterMutation{
		config:        c,
		op:            op,
		typ:           TypeNCharacter,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNCharacterID sets the ID field of the mutation.
func withNCharacterID(id int) ncharacterOption {
	return func(m *NCharacterMutation) {
		var (
			err   error
			once  sync.Once
			value *NCharacter
		)
		m.oldValue = func(ctx context.Context) (*NCharacter, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().NCharacter.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNCharacter sets the old NCharacter of the mutation.
func withNCharacter(node *NCharacter) ncharacterOption {
	return func(m *NCharacterMutation) {
		m.oldValue = func(context.Context) (*NCharacter, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NCharacterMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NCharacterMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of NCharacter entities.
func (m *NCharacterMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NCharacterMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NCharacterMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().NCharacter.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPinYin sets the "pin_yin" field.
func (m *NCharacterMutation) SetPinYin(s []string) {
	m.pin_yin = &s
	m.appendpin_yin = nil
}

// PinYin returns the value of the "pin_yin" field in the mutation.
func (m *NCharacterMutation) PinYin() (r []string, exists bool) {
	v := m.pin_yin
	if v == nil {
		return
	}
	return *v, true
}

// OldPinYin returns the old "pin_yin" field's value of the NCharacter entity.
// If the NCharacter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NCharacterMutation) OldPinYin(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPinYin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPinYin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPinYin: %w", err)
	}
	return oldValue.PinYin, nil
}

// AppendPinYin adds s to the "pin_yin" field.
func (m *NCharacterMutation) AppendPinYin(s []string) {
	m.appendpin_yin = append(m.appendpin_yin, s...)
}

// AppendedPinYin returns the list of values that were appended to the "pin_yin" field in this mutation.
func (m *NCharacterMutation) AppendedPinYin() ([]string, bool) {
	if len(m.appendpin_yin) == 0 {
		return nil, false
	}
	return m.appendpin_yin, true
}

// ResetPinYin resets all changes to the "pin_yin" field.
func (m *NCharacterMutation) ResetPinYin() {
	m.pin_yin = nil
	m.appendpin_yin = nil
}

// SetChar sets the "char" field.
func (m *NCharacterMutation) SetChar(s string) {
	m.char = &s
}

// Char returns the value of the "char" field in the mutation.
func (m *NCharacterMutation) Char() (r string, exists bool) {
	v := m.char
	if v == nil {
		return
	}
	return *v, true
}

// OldChar returns the old "char" field's value of the NCharacter entity.
// If the NCharacter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NCharacterMutation) OldChar(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChar is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChar requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChar: %w", err)
	}
	return oldValue.Char, nil
}

// ResetChar resets all changes to the "char" field.
func (m *NCharacterMutation) ResetChar() {
	m.char = nil
}

// SetCharStroke sets the "char_stroke" field.
func (m *NCharacterMutation) SetCharStroke(i int) {
	m.char_stroke = &i
	m.addchar_stroke = nil
}

// CharStroke returns the value of the "char_stroke" field in the mutation.
func (m *NCharacterMutation) CharStroke() (r int, exists bool) {
	v := m.char_stroke
	if v == nil {
		return
	}
	return *v, true
}

// OldCharStroke returns the old "char_stroke" field's value of the NCharacter entity.
// If the NCharacter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NCharacterMutation) OldCharStroke(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCharStroke is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCharStroke requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCharStroke: %w", err)
	}
	return oldValue.CharStroke, nil
}

// AddCharStroke adds i to the "char_stroke" field.
func (m *NCharacterMutation) AddCharStroke(i int) {
	if m.addchar_stroke != nil {
		*m.addchar_stroke += i
	} else {
		m.addchar_stroke = &i
	}
}

// AddedCharStroke returns the value that was added to the "char_stroke" field in this mutation.
func (m *NCharacterMutation) AddedCharStroke() (r int, exists bool) {
	v := m.addchar_stroke
	if v == nil {
		return
	}
	return *v, true
}

// ResetCharStroke resets all changes to the "char_stroke" field.
func (m *NCharacterMutation) ResetCharStroke() {
	m.char_stroke = nil
	m.addchar_stroke = nil
}

// SetRadical sets the "radical" field.
func (m *NCharacterMutation) SetRadical(s string) {
	m.radical = &s
}

// Radical returns the value of the "radical" field in the mutation.
func (m *NCharacterMutation) Radical() (r string, exists bool) {
	v := m.radical
	if v == nil {
		return
	}
	return *v, true
}

// OldRadical returns the old "radical" field's value of the NCharacter entity.
// If the NCharacter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NCharacterMutation) OldRadical(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRadical is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRadical requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRadical: %w", err)
	}
	return oldValue.Radical, nil
}

// ResetRadical resets all changes to the "radical" field.
func (m *NCharacterMutation) ResetRadical() {
	m.radical = nil
}

// SetRadicalStroke sets the "radical_stroke" field.
func (m *NCharacterMutation) SetRadicalStroke(i int) {
	m.radical_stroke = &i
	m.addradical_stroke = nil
}

// RadicalStroke returns the value of the "radical_stroke" field in the mutation.
func (m *NCharacterMutation) RadicalStroke() (r int, exists bool) {
	v := m.radical_stroke
	if v == nil {
		return
	}
	return *v, true
}

// OldRadicalStroke returns the old "radical_stroke" field's value of the NCharacter entity.
// If the NCharacter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NCharacterMutation) OldRadicalStroke(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRadicalStroke is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRadicalStroke requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRadicalStroke: %w", err)
	}
	return oldValue.RadicalStroke, nil
}

// AddRadicalStroke adds i to the "radical_stroke" field.
func (m *NCharacterMutation) AddRadicalStroke(i int) {
	if m.addradical_stroke != nil {
		*m.addradical_stroke += i
	} else {
		m.addradical_stroke = &i
	}
}

// AddedRadicalStroke returns the value that was added to the "radical_stroke" field in this mutation.
func (m *NCharacterMutation) AddedRadicalStroke() (r int, exists bool) {
	v := m.addradical_stroke
	if v == nil {
		return
	}
	return *v, true
}

// ResetRadicalStroke resets all changes to the "radical_stroke" field.
func (m *NCharacterMutation) ResetRadicalStroke() {
	m.radical_stroke = nil
	m.addradical_stroke = nil
}

// SetIsRegular sets the "is_regular" field.
func (m *NCharacterMutation) SetIsRegular(b bool) {
	m.is_regular = &b
}

// IsRegular returns the value of the "is_regular" field in the mutation.
func (m *NCharacterMutation) IsRegular() (r bool, exists bool) {
	v := m.is_regular
	if v == nil {
		return
	}
	return *v, true
}

// OldIsRegular returns the old "is_regular" field's value of the NCharacter entity.
// If the NCharacter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NCharacterMutation) OldIsRegular(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsRegular is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsRegular requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsRegular: %w", err)
	}
	return oldValue.IsRegular, nil
}

// ResetIsRegular resets all changes to the "is_regular" field.
func (m *NCharacterMutation) ResetIsRegular() {
	m.is_regular = nil
}

// SetIsSimplified sets the "is_simplified" field.
func (m *NCharacterMutation) SetIsSimplified(b bool) {
	m.is_simplified = &b
}

// IsSimplified returns the value of the "is_simplified" field in the mutation.
func (m *NCharacterMutation) IsSimplified() (r bool, exists bool) {
	v := m.is_simplified
	if v == nil {
		return
	}
	return *v, true
}

// OldIsSimplified returns the old "is_simplified" field's value of the NCharacter entity.
// If the NCharacter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NCharacterMutation) OldIsSimplified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsSimplified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsSimplified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsSimplified: %w", err)
	}
	return oldValue.IsSimplified, nil
}

// ResetIsSimplified resets all changes to the "is_simplified" field.
func (m *NCharacterMutation) ResetIsSimplified() {
	m.is_simplified = nil
}

// SetSimplifiedID sets the "simplified_id" field.
func (m *NCharacterMutation) SetSimplifiedID(i []int) {
	m.simplified_id = &i
	m.appendsimplified_id = nil
}

// SimplifiedID returns the value of the "simplified_id" field in the mutation.
func (m *NCharacterMutation) SimplifiedID() (r []int, exists bool) {
	v := m.simplified_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSimplifiedID returns the old "simplified_id" field's value of the NCharacter entity.
// If the NCharacter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NCharacterMutation) OldSimplifiedID(ctx context.Context) (v []int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSimplifiedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSimplifiedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSimplifiedID: %w", err)
	}
	return oldValue.SimplifiedID, nil
}

// AppendSimplifiedID adds i to the "simplified_id" field.
func (m *NCharacterMutation) AppendSimplifiedID(i []int) {
	m.appendsimplified_id = append(m.appendsimplified_id, i...)
}

// AppendedSimplifiedID returns the list of values that were appended to the "simplified_id" field in this mutation.
func (m *NCharacterMutation) AppendedSimplifiedID() ([]int, bool) {
	if len(m.appendsimplified_id) == 0 {
		return nil, false
	}
	return m.appendsimplified_id, true
}

// ResetSimplifiedID resets all changes to the "simplified_id" field.
func (m *NCharacterMutation) ResetSimplifiedID() {
	m.simplified_id = nil
	m.appendsimplified_id = nil
}

// SetIsTraditional sets the "is_traditional" field.
func (m *NCharacterMutation) SetIsTraditional(b bool) {
	m.is_traditional = &b
}

// IsTraditional returns the value of the "is_traditional" field in the mutation.
func (m *NCharacterMutation) IsTraditional() (r bool, exists bool) {
	v := m.is_traditional
	if v == nil {
		return
	}
	return *v, true
}

// OldIsTraditional returns the old "is_traditional" field's value of the NCharacter entity.
// If the NCharacter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NCharacterMutation) OldIsTraditional(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsTraditional is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsTraditional requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsTraditional: %w", err)
	}
	return oldValue.IsTraditional, nil
}

// ResetIsTraditional resets all changes to the "is_traditional" field.
func (m *NCharacterMutation) ResetIsTraditional() {
	m.is_traditional = nil
}

// SetTraditionalID sets the "traditional_id" field.
func (m *NCharacterMutation) SetTraditionalID(i []int) {
	m.traditional_id = &i
	m.appendtraditional_id = nil
}

// TraditionalID returns the value of the "traditional_id" field in the mutation.
func (m *NCharacterMutation) TraditionalID() (r []int, exists bool) {
	v := m.traditional_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTraditionalID returns the old "traditional_id" field's value of the NCharacter entity.
// If the NCharacter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NCharacterMutation) OldTraditionalID(ctx context.Context) (v []int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTraditionalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTraditionalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTraditionalID: %w", err)
	}
	return oldValue.TraditionalID, nil
}

// AppendTraditionalID adds i to the "traditional_id" field.
func (m *NCharacterMutation) AppendTraditionalID(i []int) {
	m.appendtraditional_id = append(m.appendtraditional_id, i...)
}

// AppendedTraditionalID returns the list of values that were appended to the "traditional_id" field in this mutation.
func (m *NCharacterMutation) AppendedTraditionalID() ([]int, bool) {
	if len(m.appendtraditional_id) == 0 {
		return nil, false
	}
	return m.appendtraditional_id, true
}

// ResetTraditionalID resets all changes to the "traditional_id" field.
func (m *NCharacterMutation) ResetTraditionalID() {
	m.traditional_id = nil
	m.appendtraditional_id = nil
}

// SetIsKangXi sets the "is_kang_xi" field.
func (m *NCharacterMutation) SetIsKangXi(b bool) {
	m.is_kang_xi = &b
}

// IsKangXi returns the value of the "is_kang_xi" field in the mutation.
func (m *NCharacterMutation) IsKangXi() (r bool, exists bool) {
	v := m.is_kang_xi
	if v == nil {
		return
	}
	return *v, true
}

// OldIsKangXi returns the old "is_kang_xi" field's value of the NCharacter entity.
// If the NCharacter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NCharacterMutation) OldIsKangXi(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsKangXi is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsKangXi requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsKangXi: %w", err)
	}
	return oldValue.IsKangXi, nil
}

// ResetIsKangXi resets all changes to the "is_kang_xi" field.
func (m *NCharacterMutation) ResetIsKangXi() {
	m.is_kang_xi = nil
}

// SetKangXiID sets the "kang_xi_id" field.
func (m *NCharacterMutation) SetKangXiID(i []int) {
	m.kang_xi_id = &i
	m.appendkang_xi_id = nil
}

// KangXiID returns the value of the "kang_xi_id" field in the mutation.
func (m *NCharacterMutation) KangXiID() (r []int, exists bool) {
	v := m.kang_xi_id
	if v == nil {
		return
	}
	return *v, true
}

// OldKangXiID returns the old "kang_xi_id" field's value of the NCharacter entity.
// If the NCharacter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NCharacterMutation) OldKangXiID(ctx context.Context) (v []int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKangXiID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKangXiID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKangXiID: %w", err)
	}
	return oldValue.KangXiID, nil
}

// AppendKangXiID adds i to the "kang_xi_id" field.
func (m *NCharacterMutation) AppendKangXiID(i []int) {
	m.appendkang_xi_id = append(m.appendkang_xi_id, i...)
}

// AppendedKangXiID returns the list of values that were appended to the "kang_xi_id" field in this mutation.
func (m *NCharacterMutation) AppendedKangXiID() ([]int, bool) {
	if len(m.appendkang_xi_id) == 0 {
		return nil, false
	}
	return m.appendkang_xi_id, true
}

// ResetKangXiID resets all changes to the "kang_xi_id" field.
func (m *NCharacterMutation) ResetKangXiID() {
	m.kang_xi_id = nil
	m.appendkang_xi_id = nil
}

// SetKangXiStroke sets the "kang_xi_stroke" field.
func (m *NCharacterMutation) SetKangXiStroke(i int) {
	m.kang_xi_stroke = &i
	m.addkang_xi_stroke = nil
}

// KangXiStroke returns the value of the "kang_xi_stroke" field in the mutation.
func (m *NCharacterMutation) KangXiStroke() (r int, exists bool) {
	v := m.kang_xi_stroke
	if v == nil {
		return
	}
	return *v, true
}

// OldKangXiStroke returns the old "kang_xi_stroke" field's value of the NCharacter entity.
// If the NCharacter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NCharacterMutation) OldKangXiStroke(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKangXiStroke is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKangXiStroke requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKangXiStroke: %w", err)
	}
	return oldValue.KangXiStroke, nil
}

// AddKangXiStroke adds i to the "kang_xi_stroke" field.
func (m *NCharacterMutation) AddKangXiStroke(i int) {
	if m.addkang_xi_stroke != nil {
		*m.addkang_xi_stroke += i
	} else {
		m.addkang_xi_stroke = &i
	}
}

// AddedKangXiStroke returns the value that was added to the "kang_xi_stroke" field in this mutation.
func (m *NCharacterMutation) AddedKangXiStroke() (r int, exists bool) {
	v := m.addkang_xi_stroke
	if v == nil {
		return
	}
	return *v, true
}

// ResetKangXiStroke resets all changes to the "kang_xi_stroke" field.
func (m *NCharacterMutation) ResetKangXiStroke() {
	m.kang_xi_stroke = nil
	m.addkang_xi_stroke = nil
}

// SetIsVariant sets the "is_variant" field.
func (m *NCharacterMutation) SetIsVariant(b bool) {
	m.is_variant = &b
}

// IsVariant returns the value of the "is_variant" field in the mutation.
func (m *NCharacterMutation) IsVariant() (r bool, exists bool) {
	v := m.is_variant
	if v == nil {
		return
	}
	return *v, true
}

// OldIsVariant returns the old "is_variant" field's value of the NCharacter entity.
// If the NCharacter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NCharacterMutation) OldIsVariant(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsVariant is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsVariant requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsVariant: %w", err)
	}
	return oldValue.IsVariant, nil
}

// ResetIsVariant resets all changes to the "is_variant" field.
func (m *NCharacterMutation) ResetIsVariant() {
	m.is_variant = nil
}

// SetVariantID sets the "variant_id" field.
func (m *NCharacterMutation) SetVariantID(i []int) {
	m.variant_id = &i
	m.appendvariant_id = nil
}

// VariantID returns the value of the "variant_id" field in the mutation.
func (m *NCharacterMutation) VariantID() (r []int, exists bool) {
	v := m.variant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldVariantID returns the old "variant_id" field's value of the NCharacter entity.
// If the NCharacter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NCharacterMutation) OldVariantID(ctx context.Context) (v []int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVariantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVariantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVariantID: %w", err)
	}
	return oldValue.VariantID, nil
}

// AppendVariantID adds i to the "variant_id" field.
func (m *NCharacterMutation) AppendVariantID(i []int) {
	m.appendvariant_id = append(m.appendvariant_id, i...)
}

// AppendedVariantID returns the list of values that were appended to the "variant_id" field in this mutation.
func (m *NCharacterMutation) AppendedVariantID() ([]int, bool) {
	if len(m.appendvariant_id) == 0 {
		return nil, false
	}
	return m.appendvariant_id, true
}

// ResetVariantID resets all changes to the "variant_id" field.
func (m *NCharacterMutation) ResetVariantID() {
	m.variant_id = nil
	m.appendvariant_id = nil
}

// SetIsScience sets the "is_science" field.
func (m *NCharacterMutation) SetIsScience(b bool) {
	m.is_science = &b
}

// IsScience returns the value of the "is_science" field in the mutation.
func (m *NCharacterMutation) IsScience() (r bool, exists bool) {
	v := m.is_science
	if v == nil {
		return
	}
	return *v, true
}

// OldIsScience returns the old "is_science" field's value of the NCharacter entity.
// If the NCharacter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NCharacterMutation) OldIsScience(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsScience is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsScience requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsScience: %w", err)
	}
	return oldValue.IsScience, nil
}

// ResetIsScience resets all changes to the "is_science" field.
func (m *NCharacterMutation) ResetIsScience() {
	m.is_science = nil
}

// SetScienceStroke sets the "science_stroke" field.
func (m *NCharacterMutation) SetScienceStroke(i int) {
	m.science_stroke = &i
	m.addscience_stroke = nil
}

// ScienceStroke returns the value of the "science_stroke" field in the mutation.
func (m *NCharacterMutation) ScienceStroke() (r int, exists bool) {
	v := m.science_stroke
	if v == nil {
		return
	}
	return *v, true
}

// OldScienceStroke returns the old "science_stroke" field's value of the NCharacter entity.
// If the NCharacter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NCharacterMutation) OldScienceStroke(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScienceStroke is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScienceStroke requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScienceStroke: %w", err)
	}
	return oldValue.ScienceStroke, nil
}

// AddScienceStroke adds i to the "science_stroke" field.
func (m *NCharacterMutation) AddScienceStroke(i int) {
	if m.addscience_stroke != nil {
		*m.addscience_stroke += i
	} else {
		m.addscience_stroke = &i
	}
}

// AddedScienceStroke returns the value that was added to the "science_stroke" field in this mutation.
func (m *NCharacterMutation) AddedScienceStroke() (r int, exists bool) {
	v := m.addscience_stroke
	if v == nil {
		return
	}
	return *v, true
}

// ResetScienceStroke resets all changes to the "science_stroke" field.
func (m *NCharacterMutation) ResetScienceStroke() {
	m.science_stroke = nil
	m.addscience_stroke = nil
}

// SetWuXing sets the "wu_xing" field.
func (m *NCharacterMutation) SetWuXing(s string) {
	m.wu_xing = &s
}

// WuXing returns the value of the "wu_xing" field in the mutation.
func (m *NCharacterMutation) WuXing() (r string, exists bool) {
	v := m.wu_xing
	if v == nil {
		return
	}
	return *v, true
}

// OldWuXing returns the old "wu_xing" field's value of the NCharacter entity.
// If the NCharacter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NCharacterMutation) OldWuXing(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWuXing is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWuXing requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWuXing: %w", err)
	}
	return oldValue.WuXing, nil
}

// ResetWuXing resets all changes to the "wu_xing" field.
func (m *NCharacterMutation) ResetWuXing() {
	m.wu_xing = nil
}

// SetLucky sets the "lucky" field.
func (m *NCharacterMutation) SetLucky(s string) {
	m.lucky = &s
}

// Lucky returns the value of the "lucky" field in the mutation.
func (m *NCharacterMutation) Lucky() (r string, exists bool) {
	v := m.lucky
	if v == nil {
		return
	}
	return *v, true
}

// OldLucky returns the old "lucky" field's value of the NCharacter entity.
// If the NCharacter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NCharacterMutation) OldLucky(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLucky is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLucky requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLucky: %w", err)
	}
	return oldValue.Lucky, nil
}

// ResetLucky resets all changes to the "lucky" field.
func (m *NCharacterMutation) ResetLucky() {
	m.lucky = nil
}

// SetExplanation sets the "explanation" field.
func (m *NCharacterMutation) SetExplanation(s string) {
	m.explanation = &s
}

// Explanation returns the value of the "explanation" field in the mutation.
func (m *NCharacterMutation) Explanation() (r string, exists bool) {
	v := m.explanation
	if v == nil {
		return
	}
	return *v, true
}

// OldExplanation returns the old "explanation" field's value of the NCharacter entity.
// If the NCharacter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NCharacterMutation) OldExplanation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExplanation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExplanation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExplanation: %w", err)
	}
	return oldValue.Explanation, nil
}

// ResetExplanation resets all changes to the "explanation" field.
func (m *NCharacterMutation) ResetExplanation() {
	m.explanation = nil
}

// SetComment sets the "comment" field.
func (m *NCharacterMutation) SetComment(s []string) {
	m.comment = &s
	m.appendcomment = nil
}

// Comment returns the value of the "comment" field in the mutation.
func (m *NCharacterMutation) Comment() (r []string, exists bool) {
	v := m.comment
	if v == nil {
		return
	}
	return *v, true
}

// OldComment returns the old "comment" field's value of the NCharacter entity.
// If the NCharacter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NCharacterMutation) OldComment(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldComment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldComment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComment: %w", err)
	}
	return oldValue.Comment, nil
}

// AppendComment adds s to the "comment" field.
func (m *NCharacterMutation) AppendComment(s []string) {
	m.appendcomment = append(m.appendcomment, s...)
}

// AppendedComment returns the list of values that were appended to the "comment" field in this mutation.
func (m *NCharacterMutation) AppendedComment() ([]string, bool) {
	if len(m.appendcomment) == 0 {
		return nil, false
	}
	return m.appendcomment, true
}

// ResetComment resets all changes to the "comment" field.
func (m *NCharacterMutation) ResetComment() {
	m.comment = nil
	m.appendcomment = nil
}

// SetNeedFix sets the "need_fix" field.
func (m *NCharacterMutation) SetNeedFix(b bool) {
	m.need_fix = &b
}

// NeedFix returns the value of the "need_fix" field in the mutation.
func (m *NCharacterMutation) NeedFix() (r bool, exists bool) {
	v := m.need_fix
	if v == nil {
		return
	}
	return *v, true
}

// OldNeedFix returns the old "need_fix" field's value of the NCharacter entity.
// If the NCharacter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NCharacterMutation) OldNeedFix(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNeedFix is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNeedFix requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNeedFix: %w", err)
	}
	return oldValue.NeedFix, nil
}

// ResetNeedFix resets all changes to the "need_fix" field.
func (m *NCharacterMutation) ResetNeedFix() {
	m.need_fix = nil
}

// Where appends a list predicates to the NCharacterMutation builder.
func (m *NCharacterMutation) Where(ps ...predicate.NCharacter) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NCharacterMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NCharacterMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.NCharacter, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NCharacterMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NCharacterMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (NCharacter).
func (m *NCharacterMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NCharacterMutation) Fields() []string {
	fields := make([]string, 0, 22)
	if m.pin_yin != nil {
		fields = append(fields, ncharacter.FieldPinYin)
	}
	if m.char != nil {
		fields = append(fields, ncharacter.FieldChar)
	}
	if m.char_stroke != nil {
		fields = append(fields, ncharacter.FieldCharStroke)
	}
	if m.radical != nil {
		fields = append(fields, ncharacter.FieldRadical)
	}
	if m.radical_stroke != nil {
		fields = append(fields, ncharacter.FieldRadicalStroke)
	}
	if m.is_regular != nil {
		fields = append(fields, ncharacter.FieldIsRegular)
	}
	if m.is_simplified != nil {
		fields = append(fields, ncharacter.FieldIsSimplified)
	}
	if m.simplified_id != nil {
		fields = append(fields, ncharacter.FieldSimplifiedID)
	}
	if m.is_traditional != nil {
		fields = append(fields, ncharacter.FieldIsTraditional)
	}
	if m.traditional_id != nil {
		fields = append(fields, ncharacter.FieldTraditionalID)
	}
	if m.is_kang_xi != nil {
		fields = append(fields, ncharacter.FieldIsKangXi)
	}
	if m.kang_xi_id != nil {
		fields = append(fields, ncharacter.FieldKangXiID)
	}
	if m.kang_xi_stroke != nil {
		fields = append(fields, ncharacter.FieldKangXiStroke)
	}
	if m.is_variant != nil {
		fields = append(fields, ncharacter.FieldIsVariant)
	}
	if m.variant_id != nil {
		fields = append(fields, ncharacter.FieldVariantID)
	}
	if m.is_science != nil {
		fields = append(fields, ncharacter.FieldIsScience)
	}
	if m.science_stroke != nil {
		fields = append(fields, ncharacter.FieldScienceStroke)
	}
	if m.wu_xing != nil {
		fields = append(fields, ncharacter.FieldWuXing)
	}
	if m.lucky != nil {
		fields = append(fields, ncharacter.FieldLucky)
	}
	if m.explanation != nil {
		fields = append(fields, ncharacter.FieldExplanation)
	}
	if m.comment != nil {
		fields = append(fields, ncharacter.FieldComment)
	}
	if m.need_fix != nil {
		fields = append(fields, ncharacter.FieldNeedFix)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NCharacterMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case ncharacter.FieldPinYin:
		return m.PinYin()
	case ncharacter.FieldChar:
		return m.Char()
	case ncharacter.FieldCharStroke:
		return m.CharStroke()
	case ncharacter.FieldRadical:
		return m.Radical()
	case ncharacter.FieldRadicalStroke:
		return m.RadicalStroke()
	case ncharacter.FieldIsRegular:
		return m.IsRegular()
	case ncharacter.FieldIsSimplified:
		return m.IsSimplified()
	case ncharacter.FieldSimplifiedID:
		return m.SimplifiedID()
	case ncharacter.FieldIsTraditional:
		return m.IsTraditional()
	case ncharacter.FieldTraditionalID:
		return m.TraditionalID()
	case ncharacter.FieldIsKangXi:
		return m.IsKangXi()
	case ncharacter.FieldKangXiID:
		return m.KangXiID()
	case ncharacter.FieldKangXiStroke:
		return m.KangXiStroke()
	case ncharacter.FieldIsVariant:
		return m.IsVariant()
	case ncharacter.FieldVariantID:
		return m.VariantID()
	case ncharacter.FieldIsScience:
		return m.IsScience()
	case ncharacter.FieldScienceStroke:
		return m.ScienceStroke()
	case ncharacter.FieldWuXing:
		return m.WuXing()
	case ncharacter.FieldLucky:
		return m.Lucky()
	case ncharacter.FieldExplanation:
		return m.Explanation()
	case ncharacter.FieldComment:
		return m.Comment()
	case ncharacter.FieldNeedFix:
		return m.NeedFix()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NCharacterMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case ncharacter.FieldPinYin:
		return m.OldPinYin(ctx)
	case ncharacter.FieldChar:
		return m.OldChar(ctx)
	case ncharacter.FieldCharStroke:
		return m.OldCharStroke(ctx)
	case ncharacter.FieldRadical:
		return m.OldRadical(ctx)
	case ncharacter.FieldRadicalStroke:
		return m.OldRadicalStroke(ctx)
	case ncharacter.FieldIsRegular:
		return m.OldIsRegular(ctx)
	case ncharacter.FieldIsSimplified:
		return m.OldIsSimplified(ctx)
	case ncharacter.FieldSimplifiedID:
		return m.OldSimplifiedID(ctx)
	case ncharacter.FieldIsTraditional:
		return m.OldIsTraditional(ctx)
	case ncharacter.FieldTraditionalID:
		return m.OldTraditionalID(ctx)
	case ncharacter.FieldIsKangXi:
		return m.OldIsKangXi(ctx)
	case ncharacter.FieldKangXiID:
		return m.OldKangXiID(ctx)
	case ncharacter.FieldKangXiStroke:
		return m.OldKangXiStroke(ctx)
	case ncharacter.FieldIsVariant:
		return m.OldIsVariant(ctx)
	case ncharacter.FieldVariantID:
		return m.OldVariantID(ctx)
	case ncharacter.FieldIsScience:
		return m.OldIsScience(ctx)
	case ncharacter.FieldScienceStroke:
		return m.OldScienceStroke(ctx)
	case ncharacter.FieldWuXing:
		return m.OldWuXing(ctx)
	case ncharacter.FieldLucky:
		return m.OldLucky(ctx)
	case ncharacter.FieldExplanation:
		return m.OldExplanation(ctx)
	case ncharacter.FieldComment:
		return m.OldComment(ctx)
	case ncharacter.FieldNeedFix:
		return m.OldNeedFix(ctx)
	}
	return nil, fmt.Errorf("unknown NCharacter field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NCharacterMutation) SetField(name string, value ent.Value) error {
	switch name {
	case ncharacter.FieldPinYin:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPinYin(v)
		return nil
	case ncharacter.FieldChar:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChar(v)
		return nil
	case ncharacter.FieldCharStroke:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCharStroke(v)
		return nil
	case ncharacter.FieldRadical:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRadical(v)
		return nil
	case ncharacter.FieldRadicalStroke:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRadicalStroke(v)
		return nil
	case ncharacter.FieldIsRegular:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsRegular(v)
		return nil
	case ncharacter.FieldIsSimplified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsSimplified(v)
		return nil
	case ncharacter.FieldSimplifiedID:
		v, ok := value.([]int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSimplifiedID(v)
		return nil
	case ncharacter.FieldIsTraditional:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsTraditional(v)
		return nil
	case ncharacter.FieldTraditionalID:
		v, ok := value.([]int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTraditionalID(v)
		return nil
	case ncharacter.FieldIsKangXi:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsKangXi(v)
		return nil
	case ncharacter.FieldKangXiID:
		v, ok := value.([]int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKangXiID(v)
		return nil
	case ncharacter.FieldKangXiStroke:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKangXiStroke(v)
		return nil
	case ncharacter.FieldIsVariant:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsVariant(v)
		return nil
	case ncharacter.FieldVariantID:
		v, ok := value.([]int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVariantID(v)
		return nil
	case ncharacter.FieldIsScience:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsScience(v)
		return nil
	case ncharacter.FieldScienceStroke:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScienceStroke(v)
		return nil
	case ncharacter.FieldWuXing:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWuXing(v)
		return nil
	case ncharacter.FieldLucky:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLucky(v)
		return nil
	case ncharacter.FieldExplanation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExplanation(v)
		return nil
	case ncharacter.FieldComment:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComment(v)
		return nil
	case ncharacter.FieldNeedFix:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNeedFix(v)
		return nil
	}
	return fmt.Errorf("unknown NCharacter field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NCharacterMutation) AddedFields() []string {
	var fields []string
	if m.addchar_stroke != nil {
		fields = append(fields, ncharacter.FieldCharStroke)
	}
	if m.addradical_stroke != nil {
		fields = append(fields, ncharacter.FieldRadicalStroke)
	}
	if m.addkang_xi_stroke != nil {
		fields = append(fields, ncharacter.FieldKangXiStroke)
	}
	if m.addscience_stroke != nil {
		fields = append(fields, ncharacter.FieldScienceStroke)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NCharacterMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case ncharacter.FieldCharStroke:
		return m.AddedCharStroke()
	case ncharacter.FieldRadicalStroke:
		return m.AddedRadicalStroke()
	case ncharacter.FieldKangXiStroke:
		return m.AddedKangXiStroke()
	case ncharacter.FieldScienceStroke:
		return m.AddedScienceStroke()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NCharacterMutation) AddField(name string, value ent.Value) error {
	switch name {
	case ncharacter.FieldCharStroke:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCharStroke(v)
		return nil
	case ncharacter.FieldRadicalStroke:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRadicalStroke(v)
		return nil
	case ncharacter.FieldKangXiStroke:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddKangXiStroke(v)
		return nil
	case ncharacter.FieldScienceStroke:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddScienceStroke(v)
		return nil
	}
	return fmt.Errorf("unknown NCharacter numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NCharacterMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NCharacterMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NCharacterMutation) ClearField(name string) error {
	return fmt.Errorf("unknown NCharacter nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NCharacterMutation) ResetField(name string) error {
	switch name {
	case ncharacter.FieldPinYin:
		m.ResetPinYin()
		return nil
	case ncharacter.FieldChar:
		m.ResetChar()
		return nil
	case ncharacter.FieldCharStroke:
		m.ResetCharStroke()
		return nil
	case ncharacter.FieldRadical:
		m.ResetRadical()
		return nil
	case ncharacter.FieldRadicalStroke:
		m.ResetRadicalStroke()
		return nil
	case ncharacter.FieldIsRegular:
		m.ResetIsRegular()
		return nil
	case ncharacter.FieldIsSimplified:
		m.ResetIsSimplified()
		return nil
	case ncharacter.FieldSimplifiedID:
		m.ResetSimplifiedID()
		return nil
	case ncharacter.FieldIsTraditional:
		m.ResetIsTraditional()
		return nil
	case ncharacter.FieldTraditionalID:
		m.ResetTraditionalID()
		return nil
	case ncharacter.FieldIsKangXi:
		m.ResetIsKangXi()
		return nil
	case ncharacter.FieldKangXiID:
		m.ResetKangXiID()
		return nil
	case ncharacter.FieldKangXiStroke:
		m.ResetKangXiStroke()
		return nil
	case ncharacter.FieldIsVariant:
		m.ResetIsVariant()
		return nil
	case ncharacter.FieldVariantID:
		m.ResetVariantID()
		return nil
	case ncharacter.FieldIsScience:
		m.ResetIsScience()
		return nil
	case ncharacter.FieldScienceStroke:
		m.ResetScienceStroke()
		return nil
	case ncharacter.FieldWuXing:
		m.ResetWuXing()
		return nil
	case ncharacter.FieldLucky:
		m.ResetLucky()
		return nil
	case ncharacter.FieldExplanation:
		m.ResetExplanation()
		return nil
	case ncharacter.FieldComment:
		m.ResetComment()
		return nil
	case ncharacter.FieldNeedFix:
		m.ResetNeedFix()
		return nil
	}
	return fmt.Errorf("unknown NCharacter field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NCharacterMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NCharacterMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NCharacterMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NCharacterMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NCharacterMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NCharacterMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NCharacterMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown NCharacter unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NCharacterMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown NCharacter edge %s", name)
}

// VersionMutation represents an operation that mutates the Version nodes in the graph.
type VersionMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	current_version    *int
	addcurrent_version *int
	updated_unix       *int
	addupdated_unix    *int
	clearedFields      map[string]struct{}
	done               bool
	oldValue           func(context.Context) (*Version, error)
	predicates         []predicate.Version
}

var _ ent.Mutation = (*VersionMutation)(nil)

// versionOption allows management of the mutation configuration using functional options.
type versionOption func(*VersionMutation)

// newVersionMutation creates new mutation for the Version entity.
func newVersionMutation(c config, op Op, opts ...versionOption) *VersionMutation {
	m := &VersionMutation{
		config:        c,
		op:            op,
		typ:           TypeVersion,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVersionID sets the ID field of the mutation.
func withVersionID(id int) versionOption {
	return func(m *VersionMutation) {
		var (
			err   error
			once  sync.Once
			value *Version
		)
		m.oldValue = func(ctx context.Context) (*Version, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Version.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVersion sets the old Version of the mutation.
func withVersion(node *Version) versionOption {
	return func(m *VersionMutation) {
		m.oldValue = func(context.Context) (*Version, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VersionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VersionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VersionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *VersionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Version.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCurrentVersion sets the "current_version" field.
func (m *VersionMutation) SetCurrentVersion(i int) {
	m.current_version = &i
	m.addcurrent_version = nil
}

// CurrentVersion returns the value of the "current_version" field in the mutation.
func (m *VersionMutation) CurrentVersion() (r int, exists bool) {
	v := m.current_version
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrentVersion returns the old "current_version" field's value of the Version entity.
// If the Version object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VersionMutation) OldCurrentVersion(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrentVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrentVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrentVersion: %w", err)
	}
	return oldValue.CurrentVersion, nil
}

// AddCurrentVersion adds i to the "current_version" field.
func (m *VersionMutation) AddCurrentVersion(i int) {
	if m.addcurrent_version != nil {
		*m.addcurrent_version += i
	} else {
		m.addcurrent_version = &i
	}
}

// AddedCurrentVersion returns the value that was added to the "current_version" field in this mutation.
func (m *VersionMutation) AddedCurrentVersion() (r int, exists bool) {
	v := m.addcurrent_version
	if v == nil {
		return
	}
	return *v, true
}

// ResetCurrentVersion resets all changes to the "current_version" field.
func (m *VersionMutation) ResetCurrentVersion() {
	m.current_version = nil
	m.addcurrent_version = nil
}

// SetUpdatedUnix sets the "updated_unix" field.
func (m *VersionMutation) SetUpdatedUnix(i int) {
	m.updated_unix = &i
	m.addupdated_unix = nil
}

// UpdatedUnix returns the value of the "updated_unix" field in the mutation.
func (m *VersionMutation) UpdatedUnix() (r int, exists bool) {
	v := m.updated_unix
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedUnix returns the old "updated_unix" field's value of the Version entity.
// If the Version object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VersionMutation) OldUpdatedUnix(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedUnix is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedUnix requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedUnix: %w", err)
	}
	return oldValue.UpdatedUnix, nil
}

// AddUpdatedUnix adds i to the "updated_unix" field.
func (m *VersionMutation) AddUpdatedUnix(i int) {
	if m.addupdated_unix != nil {
		*m.addupdated_unix += i
	} else {
		m.addupdated_unix = &i
	}
}

// AddedUpdatedUnix returns the value that was added to the "updated_unix" field in this mutation.
func (m *VersionMutation) AddedUpdatedUnix() (r int, exists bool) {
	v := m.addupdated_unix
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedUnix resets all changes to the "updated_unix" field.
func (m *VersionMutation) ResetUpdatedUnix() {
	m.updated_unix = nil
	m.addupdated_unix = nil
}

// Where appends a list predicates to the VersionMutation builder.
func (m *VersionMutation) Where(ps ...predicate.Version) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the VersionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *VersionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Version, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *VersionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *VersionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Version).
func (m *VersionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VersionMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.current_version != nil {
		fields = append(fields, version.FieldCurrentVersion)
	}
	if m.updated_unix != nil {
		fields = append(fields, version.FieldUpdatedUnix)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VersionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case version.FieldCurrentVersion:
		return m.CurrentVersion()
	case version.FieldUpdatedUnix:
		return m.UpdatedUnix()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VersionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case version.FieldCurrentVersion:
		return m.OldCurrentVersion(ctx)
	case version.FieldUpdatedUnix:
		return m.OldUpdatedUnix(ctx)
	}
	return nil, fmt.Errorf("unknown Version field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VersionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case version.FieldCurrentVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrentVersion(v)
		return nil
	case version.FieldUpdatedUnix:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedUnix(v)
		return nil
	}
	return fmt.Errorf("unknown Version field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VersionMutation) AddedFields() []string {
	var fields []string
	if m.addcurrent_version != nil {
		fields = append(fields, version.FieldCurrentVersion)
	}
	if m.addupdated_unix != nil {
		fields = append(fields, version.FieldUpdatedUnix)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VersionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case version.FieldCurrentVersion:
		return m.AddedCurrentVersion()
	case version.FieldUpdatedUnix:
		return m.AddedUpdatedUnix()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VersionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case version.FieldCurrentVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCurrentVersion(v)
		return nil
	case version.FieldUpdatedUnix:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedUnix(v)
		return nil
	}
	return fmt.Errorf("unknown Version numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VersionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VersionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VersionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Version nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VersionMutation) ResetField(name string) error {
	switch name {
	case version.FieldCurrentVersion:
		m.ResetCurrentVersion()
		return nil
	case version.FieldUpdatedUnix:
		m.ResetUpdatedUnix()
		return nil
	}
	return fmt.Errorf("unknown Version field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VersionMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VersionMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VersionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VersionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VersionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VersionMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VersionMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Version unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VersionMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Version edge %s", name)
}

// WuGeLuckyMutation represents an operation that mutates the WuGeLucky nodes in the graph.
type WuGeLuckyMutation struct {
	config
	op                Op
	typ               string
	id                *uuid.UUID
	last_stroke_1     *int
	addlast_stroke_1  *int
	last_stroke_2     *int
	addlast_stroke_2  *int
	first_stroke_1    *int
	addfirst_stroke_1 *int
	first_stroke_2    *int
	addfirst_stroke_2 *int
	tian_ge           *int
	addtian_ge        *int
	tian_da_yan       *string
	ren_ge            *int
	addren_ge         *int
	ren_da_yan        *string
	di_ge             *int
	adddi_ge          *int
	di_da_yan         *string
	wai_ge            *int
	addwai_ge         *int
	wai_da_yan        *string
	zong_ge           *int
	addzong_ge        *int
	zong_da_yan       *string
	zong_lucky        *bool
	zong_sex          *bool
	zong_max          *bool
	clearedFields     map[string]struct{}
	done              bool
	oldValue          func(context.Context) (*WuGeLucky, error)
	predicates        []predicate.WuGeLucky
}

var _ ent.Mutation = (*WuGeLuckyMutation)(nil)

// wugeluckyOption allows management of the mutation configuration using functional options.
type wugeluckyOption func(*WuGeLuckyMutation)

// newWuGeLuckyMutation creates new mutation for the WuGeLucky entity.
func newWuGeLuckyMutation(c config, op Op, opts ...wugeluckyOption) *WuGeLuckyMutation {
	m := &WuGeLuckyMutation{
		config:        c,
		op:            op,
		typ:           TypeWuGeLucky,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWuGeLuckyID sets the ID field of the mutation.
func withWuGeLuckyID(id uuid.UUID) wugeluckyOption {
	return func(m *WuGeLuckyMutation) {
		var (
			err   error
			once  sync.Once
			value *WuGeLucky
		)
		m.oldValue = func(ctx context.Context) (*WuGeLucky, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WuGeLucky.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWuGeLucky sets the old WuGeLucky of the mutation.
func withWuGeLucky(node *WuGeLucky) wugeluckyOption {
	return func(m *WuGeLuckyMutation) {
		m.oldValue = func(context.Context) (*WuGeLucky, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WuGeLuckyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WuGeLuckyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of WuGeLucky entities.
func (m *WuGeLuckyMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WuGeLuckyMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WuGeLuckyMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().WuGeLucky.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetLastStroke1 sets the "last_stroke_1" field.
func (m *WuGeLuckyMutation) SetLastStroke1(i int) {
	m.last_stroke_1 = &i
	m.addlast_stroke_1 = nil
}

// LastStroke1 returns the value of the "last_stroke_1" field in the mutation.
func (m *WuGeLuckyMutation) LastStroke1() (r int, exists bool) {
	v := m.last_stroke_1
	if v == nil {
		return
	}
	return *v, true
}

// OldLastStroke1 returns the old "last_stroke_1" field's value of the WuGeLucky entity.
// If the WuGeLucky object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WuGeLuckyMutation) OldLastStroke1(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastStroke1 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastStroke1 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastStroke1: %w", err)
	}
	return oldValue.LastStroke1, nil
}

// AddLastStroke1 adds i to the "last_stroke_1" field.
func (m *WuGeLuckyMutation) AddLastStroke1(i int) {
	if m.addlast_stroke_1 != nil {
		*m.addlast_stroke_1 += i
	} else {
		m.addlast_stroke_1 = &i
	}
}

// AddedLastStroke1 returns the value that was added to the "last_stroke_1" field in this mutation.
func (m *WuGeLuckyMutation) AddedLastStroke1() (r int, exists bool) {
	v := m.addlast_stroke_1
	if v == nil {
		return
	}
	return *v, true
}

// ResetLastStroke1 resets all changes to the "last_stroke_1" field.
func (m *WuGeLuckyMutation) ResetLastStroke1() {
	m.last_stroke_1 = nil
	m.addlast_stroke_1 = nil
}

// SetLastStroke2 sets the "last_stroke_2" field.
func (m *WuGeLuckyMutation) SetLastStroke2(i int) {
	m.last_stroke_2 = &i
	m.addlast_stroke_2 = nil
}

// LastStroke2 returns the value of the "last_stroke_2" field in the mutation.
func (m *WuGeLuckyMutation) LastStroke2() (r int, exists bool) {
	v := m.last_stroke_2
	if v == nil {
		return
	}
	return *v, true
}

// OldLastStroke2 returns the old "last_stroke_2" field's value of the WuGeLucky entity.
// If the WuGeLucky object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WuGeLuckyMutation) OldLastStroke2(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastStroke2 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastStroke2 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastStroke2: %w", err)
	}
	return oldValue.LastStroke2, nil
}

// AddLastStroke2 adds i to the "last_stroke_2" field.
func (m *WuGeLuckyMutation) AddLastStroke2(i int) {
	if m.addlast_stroke_2 != nil {
		*m.addlast_stroke_2 += i
	} else {
		m.addlast_stroke_2 = &i
	}
}

// AddedLastStroke2 returns the value that was added to the "last_stroke_2" field in this mutation.
func (m *WuGeLuckyMutation) AddedLastStroke2() (r int, exists bool) {
	v := m.addlast_stroke_2
	if v == nil {
		return
	}
	return *v, true
}

// ResetLastStroke2 resets all changes to the "last_stroke_2" field.
func (m *WuGeLuckyMutation) ResetLastStroke2() {
	m.last_stroke_2 = nil
	m.addlast_stroke_2 = nil
}

// SetFirstStroke1 sets the "first_stroke_1" field.
func (m *WuGeLuckyMutation) SetFirstStroke1(i int) {
	m.first_stroke_1 = &i
	m.addfirst_stroke_1 = nil
}

// FirstStroke1 returns the value of the "first_stroke_1" field in the mutation.
func (m *WuGeLuckyMutation) FirstStroke1() (r int, exists bool) {
	v := m.first_stroke_1
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstStroke1 returns the old "first_stroke_1" field's value of the WuGeLucky entity.
// If the WuGeLucky object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WuGeLuckyMutation) OldFirstStroke1(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstStroke1 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstStroke1 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstStroke1: %w", err)
	}
	return oldValue.FirstStroke1, nil
}

// AddFirstStroke1 adds i to the "first_stroke_1" field.
func (m *WuGeLuckyMutation) AddFirstStroke1(i int) {
	if m.addfirst_stroke_1 != nil {
		*m.addfirst_stroke_1 += i
	} else {
		m.addfirst_stroke_1 = &i
	}
}

// AddedFirstStroke1 returns the value that was added to the "first_stroke_1" field in this mutation.
func (m *WuGeLuckyMutation) AddedFirstStroke1() (r int, exists bool) {
	v := m.addfirst_stroke_1
	if v == nil {
		return
	}
	return *v, true
}

// ResetFirstStroke1 resets all changes to the "first_stroke_1" field.
func (m *WuGeLuckyMutation) ResetFirstStroke1() {
	m.first_stroke_1 = nil
	m.addfirst_stroke_1 = nil
}

// SetFirstStroke2 sets the "first_stroke_2" field.
func (m *WuGeLuckyMutation) SetFirstStroke2(i int) {
	m.first_stroke_2 = &i
	m.addfirst_stroke_2 = nil
}

// FirstStroke2 returns the value of the "first_stroke_2" field in the mutation.
func (m *WuGeLuckyMutation) FirstStroke2() (r int, exists bool) {
	v := m.first_stroke_2
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstStroke2 returns the old "first_stroke_2" field's value of the WuGeLucky entity.
// If the WuGeLucky object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WuGeLuckyMutation) OldFirstStroke2(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstStroke2 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstStroke2 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstStroke2: %w", err)
	}
	return oldValue.FirstStroke2, nil
}

// AddFirstStroke2 adds i to the "first_stroke_2" field.
func (m *WuGeLuckyMutation) AddFirstStroke2(i int) {
	if m.addfirst_stroke_2 != nil {
		*m.addfirst_stroke_2 += i
	} else {
		m.addfirst_stroke_2 = &i
	}
}

// AddedFirstStroke2 returns the value that was added to the "first_stroke_2" field in this mutation.
func (m *WuGeLuckyMutation) AddedFirstStroke2() (r int, exists bool) {
	v := m.addfirst_stroke_2
	if v == nil {
		return
	}
	return *v, true
}

// ResetFirstStroke2 resets all changes to the "first_stroke_2" field.
func (m *WuGeLuckyMutation) ResetFirstStroke2() {
	m.first_stroke_2 = nil
	m.addfirst_stroke_2 = nil
}

// SetTianGe sets the "tian_ge" field.
func (m *WuGeLuckyMutation) SetTianGe(i int) {
	m.tian_ge = &i
	m.addtian_ge = nil
}

// TianGe returns the value of the "tian_ge" field in the mutation.
func (m *WuGeLuckyMutation) TianGe() (r int, exists bool) {
	v := m.tian_ge
	if v == nil {
		return
	}
	return *v, true
}

// OldTianGe returns the old "tian_ge" field's value of the WuGeLucky entity.
// If the WuGeLucky object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WuGeLuckyMutation) OldTianGe(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTianGe is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTianGe requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTianGe: %w", err)
	}
	return oldValue.TianGe, nil
}

// AddTianGe adds i to the "tian_ge" field.
func (m *WuGeLuckyMutation) AddTianGe(i int) {
	if m.addtian_ge != nil {
		*m.addtian_ge += i
	} else {
		m.addtian_ge = &i
	}
}

// AddedTianGe returns the value that was added to the "tian_ge" field in this mutation.
func (m *WuGeLuckyMutation) AddedTianGe() (r int, exists bool) {
	v := m.addtian_ge
	if v == nil {
		return
	}
	return *v, true
}

// ResetTianGe resets all changes to the "tian_ge" field.
func (m *WuGeLuckyMutation) ResetTianGe() {
	m.tian_ge = nil
	m.addtian_ge = nil
}

// SetTianDaYan sets the "tian_da_yan" field.
func (m *WuGeLuckyMutation) SetTianDaYan(s string) {
	m.tian_da_yan = &s
}

// TianDaYan returns the value of the "tian_da_yan" field in the mutation.
func (m *WuGeLuckyMutation) TianDaYan() (r string, exists bool) {
	v := m.tian_da_yan
	if v == nil {
		return
	}
	return *v, true
}

// OldTianDaYan returns the old "tian_da_yan" field's value of the WuGeLucky entity.
// If the WuGeLucky object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WuGeLuckyMutation) OldTianDaYan(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTianDaYan is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTianDaYan requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTianDaYan: %w", err)
	}
	return oldValue.TianDaYan, nil
}

// ResetTianDaYan resets all changes to the "tian_da_yan" field.
func (m *WuGeLuckyMutation) ResetTianDaYan() {
	m.tian_da_yan = nil
}

// SetRenGe sets the "ren_ge" field.
func (m *WuGeLuckyMutation) SetRenGe(i int) {
	m.ren_ge = &i
	m.addren_ge = nil
}

// RenGe returns the value of the "ren_ge" field in the mutation.
func (m *WuGeLuckyMutation) RenGe() (r int, exists bool) {
	v := m.ren_ge
	if v == nil {
		return
	}
	return *v, true
}

// OldRenGe returns the old "ren_ge" field's value of the WuGeLucky entity.
// If the WuGeLucky object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WuGeLuckyMutation) OldRenGe(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRenGe is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRenGe requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRenGe: %w", err)
	}
	return oldValue.RenGe, nil
}

// AddRenGe adds i to the "ren_ge" field.
func (m *WuGeLuckyMutation) AddRenGe(i int) {
	if m.addren_ge != nil {
		*m.addren_ge += i
	} else {
		m.addren_ge = &i
	}
}

// AddedRenGe returns the value that was added to the "ren_ge" field in this mutation.
func (m *WuGeLuckyMutation) AddedRenGe() (r int, exists bool) {
	v := m.addren_ge
	if v == nil {
		return
	}
	return *v, true
}

// ResetRenGe resets all changes to the "ren_ge" field.
func (m *WuGeLuckyMutation) ResetRenGe() {
	m.ren_ge = nil
	m.addren_ge = nil
}

// SetRenDaYan sets the "ren_da_yan" field.
func (m *WuGeLuckyMutation) SetRenDaYan(s string) {
	m.ren_da_yan = &s
}

// RenDaYan returns the value of the "ren_da_yan" field in the mutation.
func (m *WuGeLuckyMutation) RenDaYan() (r string, exists bool) {
	v := m.ren_da_yan
	if v == nil {
		return
	}
	return *v, true
}

// OldRenDaYan returns the old "ren_da_yan" field's value of the WuGeLucky entity.
// If the WuGeLucky object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WuGeLuckyMutation) OldRenDaYan(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRenDaYan is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRenDaYan requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRenDaYan: %w", err)
	}
	return oldValue.RenDaYan, nil
}

// ResetRenDaYan resets all changes to the "ren_da_yan" field.
func (m *WuGeLuckyMutation) ResetRenDaYan() {
	m.ren_da_yan = nil
}

// SetDiGe sets the "di_ge" field.
func (m *WuGeLuckyMutation) SetDiGe(i int) {
	m.di_ge = &i
	m.adddi_ge = nil
}

// DiGe returns the value of the "di_ge" field in the mutation.
func (m *WuGeLuckyMutation) DiGe() (r int, exists bool) {
	v := m.di_ge
	if v == nil {
		return
	}
	return *v, true
}

// OldDiGe returns the old "di_ge" field's value of the WuGeLucky entity.
// If the WuGeLucky object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WuGeLuckyMutation) OldDiGe(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDiGe is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDiGe requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDiGe: %w", err)
	}
	return oldValue.DiGe, nil
}

// AddDiGe adds i to the "di_ge" field.
func (m *WuGeLuckyMutation) AddDiGe(i int) {
	if m.adddi_ge != nil {
		*m.adddi_ge += i
	} else {
		m.adddi_ge = &i
	}
}

// AddedDiGe returns the value that was added to the "di_ge" field in this mutation.
func (m *WuGeLuckyMutation) AddedDiGe() (r int, exists bool) {
	v := m.adddi_ge
	if v == nil {
		return
	}
	return *v, true
}

// ResetDiGe resets all changes to the "di_ge" field.
func (m *WuGeLuckyMutation) ResetDiGe() {
	m.di_ge = nil
	m.adddi_ge = nil
}

// SetDiDaYan sets the "di_da_yan" field.
func (m *WuGeLuckyMutation) SetDiDaYan(s string) {
	m.di_da_yan = &s
}

// DiDaYan returns the value of the "di_da_yan" field in the mutation.
func (m *WuGeLuckyMutation) DiDaYan() (r string, exists bool) {
	v := m.di_da_yan
	if v == nil {
		return
	}
	return *v, true
}

// OldDiDaYan returns the old "di_da_yan" field's value of the WuGeLucky entity.
// If the WuGeLucky object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WuGeLuckyMutation) OldDiDaYan(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDiDaYan is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDiDaYan requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDiDaYan: %w", err)
	}
	return oldValue.DiDaYan, nil
}

// ResetDiDaYan resets all changes to the "di_da_yan" field.
func (m *WuGeLuckyMutation) ResetDiDaYan() {
	m.di_da_yan = nil
}

// SetWaiGe sets the "wai_ge" field.
func (m *WuGeLuckyMutation) SetWaiGe(i int) {
	m.wai_ge = &i
	m.addwai_ge = nil
}

// WaiGe returns the value of the "wai_ge" field in the mutation.
func (m *WuGeLuckyMutation) WaiGe() (r int, exists bool) {
	v := m.wai_ge
	if v == nil {
		return
	}
	return *v, true
}

// OldWaiGe returns the old "wai_ge" field's value of the WuGeLucky entity.
// If the WuGeLucky object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WuGeLuckyMutation) OldWaiGe(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWaiGe is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWaiGe requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWaiGe: %w", err)
	}
	return oldValue.WaiGe, nil
}

// AddWaiGe adds i to the "wai_ge" field.
func (m *WuGeLuckyMutation) AddWaiGe(i int) {
	if m.addwai_ge != nil {
		*m.addwai_ge += i
	} else {
		m.addwai_ge = &i
	}
}

// AddedWaiGe returns the value that was added to the "wai_ge" field in this mutation.
func (m *WuGeLuckyMutation) AddedWaiGe() (r int, exists bool) {
	v := m.addwai_ge
	if v == nil {
		return
	}
	return *v, true
}

// ResetWaiGe resets all changes to the "wai_ge" field.
func (m *WuGeLuckyMutation) ResetWaiGe() {
	m.wai_ge = nil
	m.addwai_ge = nil
}

// SetWaiDaYan sets the "wai_da_yan" field.
func (m *WuGeLuckyMutation) SetWaiDaYan(s string) {
	m.wai_da_yan = &s
}

// WaiDaYan returns the value of the "wai_da_yan" field in the mutation.
func (m *WuGeLuckyMutation) WaiDaYan() (r string, exists bool) {
	v := m.wai_da_yan
	if v == nil {
		return
	}
	return *v, true
}

// OldWaiDaYan returns the old "wai_da_yan" field's value of the WuGeLucky entity.
// If the WuGeLucky object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WuGeLuckyMutation) OldWaiDaYan(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWaiDaYan is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWaiDaYan requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWaiDaYan: %w", err)
	}
	return oldValue.WaiDaYan, nil
}

// ResetWaiDaYan resets all changes to the "wai_da_yan" field.
func (m *WuGeLuckyMutation) ResetWaiDaYan() {
	m.wai_da_yan = nil
}

// SetZongGe sets the "zong_ge" field.
func (m *WuGeLuckyMutation) SetZongGe(i int) {
	m.zong_ge = &i
	m.addzong_ge = nil
}

// ZongGe returns the value of the "zong_ge" field in the mutation.
func (m *WuGeLuckyMutation) ZongGe() (r int, exists bool) {
	v := m.zong_ge
	if v == nil {
		return
	}
	return *v, true
}

// OldZongGe returns the old "zong_ge" field's value of the WuGeLucky entity.
// If the WuGeLucky object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WuGeLuckyMutation) OldZongGe(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldZongGe is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldZongGe requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldZongGe: %w", err)
	}
	return oldValue.ZongGe, nil
}

// AddZongGe adds i to the "zong_ge" field.
func (m *WuGeLuckyMutation) AddZongGe(i int) {
	if m.addzong_ge != nil {
		*m.addzong_ge += i
	} else {
		m.addzong_ge = &i
	}
}

// AddedZongGe returns the value that was added to the "zong_ge" field in this mutation.
func (m *WuGeLuckyMutation) AddedZongGe() (r int, exists bool) {
	v := m.addzong_ge
	if v == nil {
		return
	}
	return *v, true
}

// ResetZongGe resets all changes to the "zong_ge" field.
func (m *WuGeLuckyMutation) ResetZongGe() {
	m.zong_ge = nil
	m.addzong_ge = nil
}

// SetZongDaYan sets the "zong_da_yan" field.
func (m *WuGeLuckyMutation) SetZongDaYan(s string) {
	m.zong_da_yan = &s
}

// ZongDaYan returns the value of the "zong_da_yan" field in the mutation.
func (m *WuGeLuckyMutation) ZongDaYan() (r string, exists bool) {
	v := m.zong_da_yan
	if v == nil {
		return
	}
	return *v, true
}

// OldZongDaYan returns the old "zong_da_yan" field's value of the WuGeLucky entity.
// If the WuGeLucky object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WuGeLuckyMutation) OldZongDaYan(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldZongDaYan is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldZongDaYan requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldZongDaYan: %w", err)
	}
	return oldValue.ZongDaYan, nil
}

// ResetZongDaYan resets all changes to the "zong_da_yan" field.
func (m *WuGeLuckyMutation) ResetZongDaYan() {
	m.zong_da_yan = nil
}

// SetZongLucky sets the "zong_lucky" field.
func (m *WuGeLuckyMutation) SetZongLucky(b bool) {
	m.zong_lucky = &b
}

// ZongLucky returns the value of the "zong_lucky" field in the mutation.
func (m *WuGeLuckyMutation) ZongLucky() (r bool, exists bool) {
	v := m.zong_lucky
	if v == nil {
		return
	}
	return *v, true
}

// OldZongLucky returns the old "zong_lucky" field's value of the WuGeLucky entity.
// If the WuGeLucky object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WuGeLuckyMutation) OldZongLucky(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldZongLucky is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldZongLucky requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldZongLucky: %w", err)
	}
	return oldValue.ZongLucky, nil
}

// ResetZongLucky resets all changes to the "zong_lucky" field.
func (m *WuGeLuckyMutation) ResetZongLucky() {
	m.zong_lucky = nil
}

// SetZongSex sets the "zong_sex" field.
func (m *WuGeLuckyMutation) SetZongSex(b bool) {
	m.zong_sex = &b
}

// ZongSex returns the value of the "zong_sex" field in the mutation.
func (m *WuGeLuckyMutation) ZongSex() (r bool, exists bool) {
	v := m.zong_sex
	if v == nil {
		return
	}
	return *v, true
}

// OldZongSex returns the old "zong_sex" field's value of the WuGeLucky entity.
// If the WuGeLucky object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WuGeLuckyMutation) OldZongSex(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldZongSex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldZongSex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldZongSex: %w", err)
	}
	return oldValue.ZongSex, nil
}

// ResetZongSex resets all changes to the "zong_sex" field.
func (m *WuGeLuckyMutation) ResetZongSex() {
	m.zong_sex = nil
}

// SetZongMax sets the "zong_max" field.
func (m *WuGeLuckyMutation) SetZongMax(b bool) {
	m.zong_max = &b
}

// ZongMax returns the value of the "zong_max" field in the mutation.
func (m *WuGeLuckyMutation) ZongMax() (r bool, exists bool) {
	v := m.zong_max
	if v == nil {
		return
	}
	return *v, true
}

// OldZongMax returns the old "zong_max" field's value of the WuGeLucky entity.
// If the WuGeLucky object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WuGeLuckyMutation) OldZongMax(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldZongMax is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldZongMax requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldZongMax: %w", err)
	}
	return oldValue.ZongMax, nil
}

// ResetZongMax resets all changes to the "zong_max" field.
func (m *WuGeLuckyMutation) ResetZongMax() {
	m.zong_max = nil
}

// Where appends a list predicates to the WuGeLuckyMutation builder.
func (m *WuGeLuckyMutation) Where(ps ...predicate.WuGeLucky) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WuGeLuckyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WuGeLuckyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.WuGeLucky, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WuGeLuckyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WuGeLuckyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (WuGeLucky).
func (m *WuGeLuckyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WuGeLuckyMutation) Fields() []string {
	fields := make([]string, 0, 17)
	if m.last_stroke_1 != nil {
		fields = append(fields, wugelucky.FieldLastStroke1)
	}
	if m.last_stroke_2 != nil {
		fields = append(fields, wugelucky.FieldLastStroke2)
	}
	if m.first_stroke_1 != nil {
		fields = append(fields, wugelucky.FieldFirstStroke1)
	}
	if m.first_stroke_2 != nil {
		fields = append(fields, wugelucky.FieldFirstStroke2)
	}
	if m.tian_ge != nil {
		fields = append(fields, wugelucky.FieldTianGe)
	}
	if m.tian_da_yan != nil {
		fields = append(fields, wugelucky.FieldTianDaYan)
	}
	if m.ren_ge != nil {
		fields = append(fields, wugelucky.FieldRenGe)
	}
	if m.ren_da_yan != nil {
		fields = append(fields, wugelucky.FieldRenDaYan)
	}
	if m.di_ge != nil {
		fields = append(fields, wugelucky.FieldDiGe)
	}
	if m.di_da_yan != nil {
		fields = append(fields, wugelucky.FieldDiDaYan)
	}
	if m.wai_ge != nil {
		fields = append(fields, wugelucky.FieldWaiGe)
	}
	if m.wai_da_yan != nil {
		fields = append(fields, wugelucky.FieldWaiDaYan)
	}
	if m.zong_ge != nil {
		fields = append(fields, wugelucky.FieldZongGe)
	}
	if m.zong_da_yan != nil {
		fields = append(fields, wugelucky.FieldZongDaYan)
	}
	if m.zong_lucky != nil {
		fields = append(fields, wugelucky.FieldZongLucky)
	}
	if m.zong_sex != nil {
		fields = append(fields, wugelucky.FieldZongSex)
	}
	if m.zong_max != nil {
		fields = append(fields, wugelucky.FieldZongMax)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WuGeLuckyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case wugelucky.FieldLastStroke1:
		return m.LastStroke1()
	case wugelucky.FieldLastStroke2:
		return m.LastStroke2()
	case wugelucky.FieldFirstStroke1:
		return m.FirstStroke1()
	case wugelucky.FieldFirstStroke2:
		return m.FirstStroke2()
	case wugelucky.FieldTianGe:
		return m.TianGe()
	case wugelucky.FieldTianDaYan:
		return m.TianDaYan()
	case wugelucky.FieldRenGe:
		return m.RenGe()
	case wugelucky.FieldRenDaYan:
		return m.RenDaYan()
	case wugelucky.FieldDiGe:
		return m.DiGe()
	case wugelucky.FieldDiDaYan:
		return m.DiDaYan()
	case wugelucky.FieldWaiGe:
		return m.WaiGe()
	case wugelucky.FieldWaiDaYan:
		return m.WaiDaYan()
	case wugelucky.FieldZongGe:
		return m.ZongGe()
	case wugelucky.FieldZongDaYan:
		return m.ZongDaYan()
	case wugelucky.FieldZongLucky:
		return m.ZongLucky()
	case wugelucky.FieldZongSex:
		return m.ZongSex()
	case wugelucky.FieldZongMax:
		return m.ZongMax()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WuGeLuckyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case wugelucky.FieldLastStroke1:
		return m.OldLastStroke1(ctx)
	case wugelucky.FieldLastStroke2:
		return m.OldLastStroke2(ctx)
	case wugelucky.FieldFirstStroke1:
		return m.OldFirstStroke1(ctx)
	case wugelucky.FieldFirstStroke2:
		return m.OldFirstStroke2(ctx)
	case wugelucky.FieldTianGe:
		return m.OldTianGe(ctx)
	case wugelucky.FieldTianDaYan:
		return m.OldTianDaYan(ctx)
	case wugelucky.FieldRenGe:
		return m.OldRenGe(ctx)
	case wugelucky.FieldRenDaYan:
		return m.OldRenDaYan(ctx)
	case wugelucky.FieldDiGe:
		return m.OldDiGe(ctx)
	case wugelucky.FieldDiDaYan:
		return m.OldDiDaYan(ctx)
	case wugelucky.FieldWaiGe:
		return m.OldWaiGe(ctx)
	case wugelucky.FieldWaiDaYan:
		return m.OldWaiDaYan(ctx)
	case wugelucky.FieldZongGe:
		return m.OldZongGe(ctx)
	case wugelucky.FieldZongDaYan:
		return m.OldZongDaYan(ctx)
	case wugelucky.FieldZongLucky:
		return m.OldZongLucky(ctx)
	case wugelucky.FieldZongSex:
		return m.OldZongSex(ctx)
	case wugelucky.FieldZongMax:
		return m.OldZongMax(ctx)
	}
	return nil, fmt.Errorf("unknown WuGeLucky field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WuGeLuckyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case wugelucky.FieldLastStroke1:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastStroke1(v)
		return nil
	case wugelucky.FieldLastStroke2:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastStroke2(v)
		return nil
	case wugelucky.FieldFirstStroke1:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstStroke1(v)
		return nil
	case wugelucky.FieldFirstStroke2:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstStroke2(v)
		return nil
	case wugelucky.FieldTianGe:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTianGe(v)
		return nil
	case wugelucky.FieldTianDaYan:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTianDaYan(v)
		return nil
	case wugelucky.FieldRenGe:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRenGe(v)
		return nil
	case wugelucky.FieldRenDaYan:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRenDaYan(v)
		return nil
	case wugelucky.FieldDiGe:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDiGe(v)
		return nil
	case wugelucky.FieldDiDaYan:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDiDaYan(v)
		return nil
	case wugelucky.FieldWaiGe:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWaiGe(v)
		return nil
	case wugelucky.FieldWaiDaYan:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWaiDaYan(v)
		return nil
	case wugelucky.FieldZongGe:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetZongGe(v)
		return nil
	case wugelucky.FieldZongDaYan:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetZongDaYan(v)
		return nil
	case wugelucky.FieldZongLucky:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetZongLucky(v)
		return nil
	case wugelucky.FieldZongSex:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetZongSex(v)
		return nil
	case wugelucky.FieldZongMax:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetZongMax(v)
		return nil
	}
	return fmt.Errorf("unknown WuGeLucky field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WuGeLuckyMutation) AddedFields() []string {
	var fields []string
	if m.addlast_stroke_1 != nil {
		fields = append(fields, wugelucky.FieldLastStroke1)
	}
	if m.addlast_stroke_2 != nil {
		fields = append(fields, wugelucky.FieldLastStroke2)
	}
	if m.addfirst_stroke_1 != nil {
		fields = append(fields, wugelucky.FieldFirstStroke1)
	}
	if m.addfirst_stroke_2 != nil {
		fields = append(fields, wugelucky.FieldFirstStroke2)
	}
	if m.addtian_ge != nil {
		fields = append(fields, wugelucky.FieldTianGe)
	}
	if m.addren_ge != nil {
		fields = append(fields, wugelucky.FieldRenGe)
	}
	if m.adddi_ge != nil {
		fields = append(fields, wugelucky.FieldDiGe)
	}
	if m.addwai_ge != nil {
		fields = append(fields, wugelucky.FieldWaiGe)
	}
	if m.addzong_ge != nil {
		fields = append(fields, wugelucky.FieldZongGe)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WuGeLuckyMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case wugelucky.FieldLastStroke1:
		return m.AddedLastStroke1()
	case wugelucky.FieldLastStroke2:
		return m.AddedLastStroke2()
	case wugelucky.FieldFirstStroke1:
		return m.AddedFirstStroke1()
	case wugelucky.FieldFirstStroke2:
		return m.AddedFirstStroke2()
	case wugelucky.FieldTianGe:
		return m.AddedTianGe()
	case wugelucky.FieldRenGe:
		return m.AddedRenGe()
	case wugelucky.FieldDiGe:
		return m.AddedDiGe()
	case wugelucky.FieldWaiGe:
		return m.AddedWaiGe()
	case wugelucky.FieldZongGe:
		return m.AddedZongGe()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WuGeLuckyMutation) AddField(name string, value ent.Value) error {
	switch name {
	case wugelucky.FieldLastStroke1:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLastStroke1(v)
		return nil
	case wugelucky.FieldLastStroke2:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLastStroke2(v)
		return nil
	case wugelucky.FieldFirstStroke1:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFirstStroke1(v)
		return nil
	case wugelucky.FieldFirstStroke2:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFirstStroke2(v)
		return nil
	case wugelucky.FieldTianGe:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTianGe(v)
		return nil
	case wugelucky.FieldRenGe:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRenGe(v)
		return nil
	case wugelucky.FieldDiGe:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDiGe(v)
		return nil
	case wugelucky.FieldWaiGe:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWaiGe(v)
		return nil
	case wugelucky.FieldZongGe:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddZongGe(v)
		return nil
	}
	return fmt.Errorf("unknown WuGeLucky numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WuGeLuckyMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WuGeLuckyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WuGeLuckyMutation) ClearField(name string) error {
	return fmt.Errorf("unknown WuGeLucky nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WuGeLuckyMutation) ResetField(name string) error {
	switch name {
	case wugelucky.FieldLastStroke1:
		m.ResetLastStroke1()
		return nil
	case wugelucky.FieldLastStroke2:
		m.ResetLastStroke2()
		return nil
	case wugelucky.FieldFirstStroke1:
		m.ResetFirstStroke1()
		return nil
	case wugelucky.FieldFirstStroke2:
		m.ResetFirstStroke2()
		return nil
	case wugelucky.FieldTianGe:
		m.ResetTianGe()
		return nil
	case wugelucky.FieldTianDaYan:
		m.ResetTianDaYan()
		return nil
	case wugelucky.FieldRenGe:
		m.ResetRenGe()
		return nil
	case wugelucky.FieldRenDaYan:
		m.ResetRenDaYan()
		return nil
	case wugelucky.FieldDiGe:
		m.ResetDiGe()
		return nil
	case wugelucky.FieldDiDaYan:
		m.ResetDiDaYan()
		return nil
	case wugelucky.FieldWaiGe:
		m.ResetWaiGe()
		return nil
	case wugelucky.FieldWaiDaYan:
		m.ResetWaiDaYan()
		return nil
	case wugelucky.FieldZongGe:
		m.ResetZongGe()
		return nil
	case wugelucky.FieldZongDaYan:
		m.ResetZongDaYan()
		return nil
	case wugelucky.FieldZongLucky:
		m.ResetZongLucky()
		return nil
	case wugelucky.FieldZongSex:
		m.ResetZongSex()
		return nil
	case wugelucky.FieldZongMax:
		m.ResetZongMax()
		return nil
	}
	return fmt.Errorf("unknown WuGeLucky field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WuGeLuckyMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WuGeLuckyMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WuGeLuckyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WuGeLuckyMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WuGeLuckyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WuGeLuckyMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WuGeLuckyMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown WuGeLucky unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WuGeLuckyMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown WuGeLucky edge %s", name)
}

// WuXingMutation represents an operation that mutates the WuXing nodes in the graph.
type WuXingMutation struct {
	config
	op            Op
	typ           string
	id            *string
	created       *time.Time
	updated       *time.Time
	deleted       *time.Time
	version       *int
	addversion    *int
	first         *string
	second        *string
	third         *string
	fortune       *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*WuXing, error)
	predicates    []predicate.WuXing
}

var _ ent.Mutation = (*WuXingMutation)(nil)

// wuxingOption allows management of the mutation configuration using functional options.
type wuxingOption func(*WuXingMutation)

// newWuXingMutation creates new mutation for the WuXing entity.
func newWuXingMutation(c config, op Op, opts ...wuxingOption) *WuXingMutation {
	m := &WuXingMutation{
		config:        c,
		op:            op,
		typ:           TypeWuXing,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWuXingID sets the ID field of the mutation.
func withWuXingID(id string) wuxingOption {
	return func(m *WuXingMutation) {
		var (
			err   error
			once  sync.Once
			value *WuXing
		)
		m.oldValue = func(ctx context.Context) (*WuXing, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WuXing.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWuXing sets the old WuXing of the mutation.
func withWuXing(node *WuXing) wuxingOption {
	return func(m *WuXingMutation) {
		m.oldValue = func(context.Context) (*WuXing, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WuXingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WuXingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of WuXing entities.
func (m *WuXingMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WuXingMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WuXingMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().WuXing.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreated sets the "created" field.
func (m *WuXingMutation) SetCreated(t time.Time) {
	m.created = &t
}

// Created returns the value of the "created" field in the mutation.
func (m *WuXingMutation) Created() (r time.Time, exists bool) {
	v := m.created
	if v == nil {
		return
	}
	return *v, true
}

// OldCreated returns the old "created" field's value of the WuXing entity.
// If the WuXing object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WuXingMutation) OldCreated(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreated: %w", err)
	}
	return oldValue.Created, nil
}

// ClearCreated clears the value of the "created" field.
func (m *WuXingMutation) ClearCreated() {
	m.created = nil
	m.clearedFields[wuxing.FieldCreated] = struct{}{}
}

// CreatedCleared returns if the "created" field was cleared in this mutation.
func (m *WuXingMutation) CreatedCleared() bool {
	_, ok := m.clearedFields[wuxing.FieldCreated]
	return ok
}

// ResetCreated resets all changes to the "created" field.
func (m *WuXingMutation) ResetCreated() {
	m.created = nil
	delete(m.clearedFields, wuxing.FieldCreated)
}

// SetUpdated sets the "updated" field.
func (m *WuXingMutation) SetUpdated(t time.Time) {
	m.updated = &t
}

// Updated returns the value of the "updated" field in the mutation.
func (m *WuXingMutation) Updated() (r time.Time, exists bool) {
	v := m.updated
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdated returns the old "updated" field's value of the WuXing entity.
// If the WuXing object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WuXingMutation) OldUpdated(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdated: %w", err)
	}
	return oldValue.Updated, nil
}

// ClearUpdated clears the value of the "updated" field.
func (m *WuXingMutation) ClearUpdated() {
	m.updated = nil
	m.clearedFields[wuxing.FieldUpdated] = struct{}{}
}

// UpdatedCleared returns if the "updated" field was cleared in this mutation.
func (m *WuXingMutation) UpdatedCleared() bool {
	_, ok := m.clearedFields[wuxing.FieldUpdated]
	return ok
}

// ResetUpdated resets all changes to the "updated" field.
func (m *WuXingMutation) ResetUpdated() {
	m.updated = nil
	delete(m.clearedFields, wuxing.FieldUpdated)
}

// SetDeleted sets the "deleted" field.
func (m *WuXingMutation) SetDeleted(t time.Time) {
	m.deleted = &t
}

// Deleted returns the value of the "deleted" field in the mutation.
func (m *WuXingMutation) Deleted() (r time.Time, exists bool) {
	v := m.deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleted returns the old "deleted" field's value of the WuXing entity.
// If the WuXing object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WuXingMutation) OldDeleted(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeleted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleted: %w", err)
	}
	return oldValue.Deleted, nil
}

// ClearDeleted clears the value of the "deleted" field.
func (m *WuXingMutation) ClearDeleted() {
	m.deleted = nil
	m.clearedFields[wuxing.FieldDeleted] = struct{}{}
}

// DeletedCleared returns if the "deleted" field was cleared in this mutation.
func (m *WuXingMutation) DeletedCleared() bool {
	_, ok := m.clearedFields[wuxing.FieldDeleted]
	return ok
}

// ResetDeleted resets all changes to the "deleted" field.
func (m *WuXingMutation) ResetDeleted() {
	m.deleted = nil
	delete(m.clearedFields, wuxing.FieldDeleted)
}

// SetVersion sets the "version" field.
func (m *WuXingMutation) SetVersion(i int) {
	m.version = &i
	m.addversion = nil
}

// Version returns the value of the "version" field in the mutation.
func (m *WuXingMutation) Version() (r int, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the WuXing entity.
// If the WuXing object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WuXingMutation) OldVersion(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds i to the "version" field.
func (m *WuXingMutation) AddVersion(i int) {
	if m.addversion != nil {
		*m.addversion += i
	} else {
		m.addversion = &i
	}
}

// AddedVersion returns the value that was added to the "version" field in this mutation.
func (m *WuXingMutation) AddedVersion() (r int, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ClearVersion clears the value of the "version" field.
func (m *WuXingMutation) ClearVersion() {
	m.version = nil
	m.addversion = nil
	m.clearedFields[wuxing.FieldVersion] = struct{}{}
}

// VersionCleared returns if the "version" field was cleared in this mutation.
func (m *WuXingMutation) VersionCleared() bool {
	_, ok := m.clearedFields[wuxing.FieldVersion]
	return ok
}

// ResetVersion resets all changes to the "version" field.
func (m *WuXingMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
	delete(m.clearedFields, wuxing.FieldVersion)
}

// SetFirst sets the "first" field.
func (m *WuXingMutation) SetFirst(s string) {
	m.first = &s
}

// First returns the value of the "first" field in the mutation.
func (m *WuXingMutation) First() (r string, exists bool) {
	v := m.first
	if v == nil {
		return
	}
	return *v, true
}

// OldFirst returns the old "first" field's value of the WuXing entity.
// If the WuXing object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WuXingMutation) OldFirst(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirst is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirst requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirst: %w", err)
	}
	return oldValue.First, nil
}

// ClearFirst clears the value of the "first" field.
func (m *WuXingMutation) ClearFirst() {
	m.first = nil
	m.clearedFields[wuxing.FieldFirst] = struct{}{}
}

// FirstCleared returns if the "first" field was cleared in this mutation.
func (m *WuXingMutation) FirstCleared() bool {
	_, ok := m.clearedFields[wuxing.FieldFirst]
	return ok
}

// ResetFirst resets all changes to the "first" field.
func (m *WuXingMutation) ResetFirst() {
	m.first = nil
	delete(m.clearedFields, wuxing.FieldFirst)
}

// SetSecond sets the "second" field.
func (m *WuXingMutation) SetSecond(s string) {
	m.second = &s
}

// Second returns the value of the "second" field in the mutation.
func (m *WuXingMutation) Second() (r string, exists bool) {
	v := m.second
	if v == nil {
		return
	}
	return *v, true
}

// OldSecond returns the old "second" field's value of the WuXing entity.
// If the WuXing object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WuXingMutation) OldSecond(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSecond is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSecond requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSecond: %w", err)
	}
	return oldValue.Second, nil
}

// ClearSecond clears the value of the "second" field.
func (m *WuXingMutation) ClearSecond() {
	m.second = nil
	m.clearedFields[wuxing.FieldSecond] = struct{}{}
}

// SecondCleared returns if the "second" field was cleared in this mutation.
func (m *WuXingMutation) SecondCleared() bool {
	_, ok := m.clearedFields[wuxing.FieldSecond]
	return ok
}

// ResetSecond resets all changes to the "second" field.
func (m *WuXingMutation) ResetSecond() {
	m.second = nil
	delete(m.clearedFields, wuxing.FieldSecond)
}

// SetThird sets the "third" field.
func (m *WuXingMutation) SetThird(s string) {
	m.third = &s
}

// Third returns the value of the "third" field in the mutation.
func (m *WuXingMutation) Third() (r string, exists bool) {
	v := m.third
	if v == nil {
		return
	}
	return *v, true
}

// OldThird returns the old "third" field's value of the WuXing entity.
// If the WuXing object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WuXingMutation) OldThird(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThird is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThird requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThird: %w", err)
	}
	return oldValue.Third, nil
}

// ClearThird clears the value of the "third" field.
func (m *WuXingMutation) ClearThird() {
	m.third = nil
	m.clearedFields[wuxing.FieldThird] = struct{}{}
}

// ThirdCleared returns if the "third" field was cleared in this mutation.
func (m *WuXingMutation) ThirdCleared() bool {
	_, ok := m.clearedFields[wuxing.FieldThird]
	return ok
}

// ResetThird resets all changes to the "third" field.
func (m *WuXingMutation) ResetThird() {
	m.third = nil
	delete(m.clearedFields, wuxing.FieldThird)
}

// SetFortune sets the "fortune" field.
func (m *WuXingMutation) SetFortune(s string) {
	m.fortune = &s
}

// Fortune returns the value of the "fortune" field in the mutation.
func (m *WuXingMutation) Fortune() (r string, exists bool) {
	v := m.fortune
	if v == nil {
		return
	}
	return *v, true
}

// OldFortune returns the old "fortune" field's value of the WuXing entity.
// If the WuXing object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WuXingMutation) OldFortune(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFortune is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFortune requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFortune: %w", err)
	}
	return oldValue.Fortune, nil
}

// ClearFortune clears the value of the "fortune" field.
func (m *WuXingMutation) ClearFortune() {
	m.fortune = nil
	m.clearedFields[wuxing.FieldFortune] = struct{}{}
}

// FortuneCleared returns if the "fortune" field was cleared in this mutation.
func (m *WuXingMutation) FortuneCleared() bool {
	_, ok := m.clearedFields[wuxing.FieldFortune]
	return ok
}

// ResetFortune resets all changes to the "fortune" field.
func (m *WuXingMutation) ResetFortune() {
	m.fortune = nil
	delete(m.clearedFields, wuxing.FieldFortune)
}

// Where appends a list predicates to the WuXingMutation builder.
func (m *WuXingMutation) Where(ps ...predicate.WuXing) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WuXingMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WuXingMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.WuXing, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WuXingMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WuXingMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (WuXing).
func (m *WuXingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WuXingMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created != nil {
		fields = append(fields, wuxing.FieldCreated)
	}
	if m.updated != nil {
		fields = append(fields, wuxing.FieldUpdated)
	}
	if m.deleted != nil {
		fields = append(fields, wuxing.FieldDeleted)
	}
	if m.version != nil {
		fields = append(fields, wuxing.FieldVersion)
	}
	if m.first != nil {
		fields = append(fields, wuxing.FieldFirst)
	}
	if m.second != nil {
		fields = append(fields, wuxing.FieldSecond)
	}
	if m.third != nil {
		fields = append(fields, wuxing.FieldThird)
	}
	if m.fortune != nil {
		fields = append(fields, wuxing.FieldFortune)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WuXingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case wuxing.FieldCreated:
		return m.Created()
	case wuxing.FieldUpdated:
		return m.Updated()
	case wuxing.FieldDeleted:
		return m.Deleted()
	case wuxing.FieldVersion:
		return m.Version()
	case wuxing.FieldFirst:
		return m.First()
	case wuxing.FieldSecond:
		return m.Second()
	case wuxing.FieldThird:
		return m.Third()
	case wuxing.FieldFortune:
		return m.Fortune()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WuXingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case wuxing.FieldCreated:
		return m.OldCreated(ctx)
	case wuxing.FieldUpdated:
		return m.OldUpdated(ctx)
	case wuxing.FieldDeleted:
		return m.OldDeleted(ctx)
	case wuxing.FieldVersion:
		return m.OldVersion(ctx)
	case wuxing.FieldFirst:
		return m.OldFirst(ctx)
	case wuxing.FieldSecond:
		return m.OldSecond(ctx)
	case wuxing.FieldThird:
		return m.OldThird(ctx)
	case wuxing.FieldFortune:
		return m.OldFortune(ctx)
	}
	return nil, fmt.Errorf("unknown WuXing field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WuXingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case wuxing.FieldCreated:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreated(v)
		return nil
	case wuxing.FieldUpdated:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdated(v)
		return nil
	case wuxing.FieldDeleted:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleted(v)
		return nil
	case wuxing.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case wuxing.FieldFirst:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirst(v)
		return nil
	case wuxing.FieldSecond:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSecond(v)
		return nil
	case wuxing.FieldThird:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThird(v)
		return nil
	case wuxing.FieldFortune:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFortune(v)
		return nil
	}
	return fmt.Errorf("unknown WuXing field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WuXingMutation) AddedFields() []string {
	var fields []string
	if m.addversion != nil {
		fields = append(fields, wuxing.FieldVersion)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WuXingMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case wuxing.FieldVersion:
		return m.AddedVersion()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WuXingMutation) AddField(name string, value ent.Value) error {
	switch name {
	case wuxing.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	}
	return fmt.Errorf("unknown WuXing numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WuXingMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(wuxing.FieldCreated) {
		fields = append(fields, wuxing.FieldCreated)
	}
	if m.FieldCleared(wuxing.FieldUpdated) {
		fields = append(fields, wuxing.FieldUpdated)
	}
	if m.FieldCleared(wuxing.FieldDeleted) {
		fields = append(fields, wuxing.FieldDeleted)
	}
	if m.FieldCleared(wuxing.FieldVersion) {
		fields = append(fields, wuxing.FieldVersion)
	}
	if m.FieldCleared(wuxing.FieldFirst) {
		fields = append(fields, wuxing.FieldFirst)
	}
	if m.FieldCleared(wuxing.FieldSecond) {
		fields = append(fields, wuxing.FieldSecond)
	}
	if m.FieldCleared(wuxing.FieldThird) {
		fields = append(fields, wuxing.FieldThird)
	}
	if m.FieldCleared(wuxing.FieldFortune) {
		fields = append(fields, wuxing.FieldFortune)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WuXingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WuXingMutation) ClearField(name string) error {
	switch name {
	case wuxing.FieldCreated:
		m.ClearCreated()
		return nil
	case wuxing.FieldUpdated:
		m.ClearUpdated()
		return nil
	case wuxing.FieldDeleted:
		m.ClearDeleted()
		return nil
	case wuxing.FieldVersion:
		m.ClearVersion()
		return nil
	case wuxing.FieldFirst:
		m.ClearFirst()
		return nil
	case wuxing.FieldSecond:
		m.ClearSecond()
		return nil
	case wuxing.FieldThird:
		m.ClearThird()
		return nil
	case wuxing.FieldFortune:
		m.ClearFortune()
		return nil
	}
	return fmt.Errorf("unknown WuXing nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WuXingMutation) ResetField(name string) error {
	switch name {
	case wuxing.FieldCreated:
		m.ResetCreated()
		return nil
	case wuxing.FieldUpdated:
		m.ResetUpdated()
		return nil
	case wuxing.FieldDeleted:
		m.ResetDeleted()
		return nil
	case wuxing.FieldVersion:
		m.ResetVersion()
		return nil
	case wuxing.FieldFirst:
		m.ResetFirst()
		return nil
	case wuxing.FieldSecond:
		m.ResetSecond()
		return nil
	case wuxing.FieldThird:
		m.ResetThird()
		return nil
	case wuxing.FieldFortune:
		m.ResetFortune()
		return nil
	}
	return fmt.Errorf("unknown WuXing field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WuXingMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WuXingMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WuXingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WuXingMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WuXingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WuXingMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WuXingMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown WuXing unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WuXingMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown WuXing edge %s", name)
}
